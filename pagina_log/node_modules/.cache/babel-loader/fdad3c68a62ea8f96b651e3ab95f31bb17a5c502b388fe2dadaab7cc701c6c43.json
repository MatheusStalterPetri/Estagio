{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = config => Object.assign({\n  type: FlowLayout\n}, config);\nfunction leadingMargin(direction) {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n  constructor() {\n    this._childSizeCache = new SizeCache();\n    this._marginSizeCache = new SizeCache();\n    this._metricsCache = new Map();\n  }\n  update(metrics, direction) {\n    var _a, _b;\n    const marginsToUpdate = new Set();\n    Object.keys(metrics).forEach(key => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n      const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n  get averageChildSize() {\n    return this._childSizeCache.averageSize;\n  }\n  get totalChildSize() {\n    return this._childSizeCache.totalSize;\n  }\n  get averageMarginSize() {\n    return this._marginSizeCache.averageSize;\n  }\n  get totalMarginSize() {\n    return this._marginSizeCache.totalSize;\n  }\n  getLeadingMarginValue(index, direction) {\n    var _a;\n    return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n  }\n  getChildSize(index) {\n    return this._childSizeCache.getSize(index);\n  }\n  getMarginSize(index) {\n    return this._marginSizeCache.getSize(index);\n  }\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n}\nexport class FlowLayout extends BaseLayout {\n  constructor() {\n    super(...arguments);\n    /**\n     * Initial estimate of item size\n     */\n    this._itemSize = {\n      width: 100,\n      height: 100\n    };\n    /**\n     * Indices of children mapped to their (position and length) in the scrolling\n     * direction. Used to keep track of children that are in range.\n     */\n    this._physicalItems = new Map();\n    /**\n     * Used in tandem with _physicalItems to track children in range across\n     * reflows.\n     */\n    this._newPhysicalItems = new Map();\n    /**\n     * Width and height of children by their index.\n     */\n    this._metricsCache = new MetricsCache();\n    /**\n     * anchorIdx is the anchor around which we reflow. It is designed to allow\n     * jumping to any point of the scroll size. We choose it once and stick with\n     * it until stable. _first and _last are deduced around it.\n     */\n    this._anchorIdx = null;\n    /**\n     * Position in the scrolling direction of the anchor child.\n     */\n    this._anchorPos = null;\n    /**\n     * Whether all children in range were in range during the previous reflow.\n     */\n    this._stable = true;\n    this._measureChildren = true;\n    this._estimate = true;\n  }\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n  // })\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n  get measureChildren() {\n    return this._measureChildren;\n  }\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes) {\n    this._metricsCache.update(sizes, this.direction);\n    // if (this._nMeasured) {\n    // this._updateItemSize();\n    this._scheduleReflow();\n    // }\n  }\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n  _getPhysicalItem(idx) {\n    var _a;\n    return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n  }\n  _getSize(idx) {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n  _getAverageSize() {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n  _estimatePosition(idx) {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return c.averageMarginSize + idx * (c.averageMarginSize + this._getAverageSize());\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return refItem.pos - (c.getMarginSize(this._first - 1) || c.averageMarginSize) - (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize);\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return refItem.pos + (c.getChildSize(this._last) || c.averageChildSize) + (c.getMarginSize(this._last) || c.averageMarginSize) + delta * (c.averageChildSize + c.averageMarginSize);\n      }\n    }\n  }\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx) {\n    var _a;\n    const item = this._getPhysicalItem(idx);\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return idx === 0 ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize : item ? item.pos : this._estimatePosition(idx);\n  }\n  _calculateAnchor(lower, upper) {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n  }\n  _getAnchor(lower, upper) {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    const firstItem = this._getPhysicalItem(this._first),\n      lastItem = this._getPhysicalItem(this._last),\n      firstMin = firstItem.pos,\n      lastMin = lastItem.pos,\n      lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n    }\n    return candidateIdx;\n  }\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    var _a, _b;\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n    // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n    // If we have a pinned item, we anchor on it\n    if (this.pin !== null) {\n      const {\n        index\n      } = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n    // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n    // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n    const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n    // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n    let anchorErr = 0;\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n    items.set(this._anchorIdx, {\n      pos: this._anchorPos,\n      size: anchorSize\n    });\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, {\n        pos,\n        size\n      });\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, {\n        pos,\n        size\n      });\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n    // This handles the cases where we were relying on estimated sizes.\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach(item => item.pos -= extentErr);\n      this._scrollError += extentErr;\n    }\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n  _calculateError() {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return this._physicalMax - this._scrollSize + (this.items.length - 1 - this._last) * this._delta;\n    }\n    return 0;\n  }\n  // TODO: Can this be made to inherit from base, with proper hooks?\n  _reflow() {\n    const {\n      _first,\n      _last,\n      _scrollSize,\n      _firstVisible,\n      _lastVisible\n    } = this;\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    if (this._scrollSize !== _scrollSize) {\n      this._emitScrollSize();\n    }\n    if (this._first !== _first || this._last !== _last || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible) {\n      this._emitRange();\n    }\n    if (!(this._first === -1 && this._last === -1)) {\n      this._emitChildPositions();\n    }\n    if (this._scrollError !== 0) {\n      this._emitScrollError();\n    }\n    if (this._first === -1 && this._last == -1 || this._first === _first && this._last === _last) {\n      this._resetReflowState();\n    }\n  }\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n  _updateScrollSize() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) + averageMarginSize);\n  }\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  get _delta() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx) {\n    var _a;\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize)\n    };\n  }\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx) {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim]\n    };\n  }\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n}","map":{"version":3,"names":["SizeCache","BaseLayout","dim1","flow","config","Object","assign","type","FlowLayout","leadingMargin","direction","trailingMargin","offset","collapseMargins","a","b","m","sort","Math","min","max","MetricsCache","constructor","_childSizeCache","_marginSizeCache","_metricsCache","Map","update","metrics","marginsToUpdate","Set","keys","forEach","key","k","Number","set","add","_a","get","_b","averageChildSize","averageSize","totalChildSize","totalSize","averageMarginSize","totalMarginSize","getLeadingMarginValue","index","getChildSize","getSize","getMarginSize","clear","_itemSize","width","height","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","measureChildren","updateItemSizes","sizes","_scheduleReflow","_getPhysicalItem","idx","_getSize","item","_getAverageSize","_sizeDim","_estimatePosition","c","_first","_last","delta","refItem","pos","_getPosition","_calculateAnchor","lower","upper","_scrollSize","_viewDim1","items","length","floor","_delta","_getAnchor","size","firstItem","lastItem","firstMin","lastMin","lastMax","candidateIdx","_firstVisible","cMax","Infinity","candidate","_getActiveItems","_clearItems","_getItems","_physicalMin","_physicalMax","pin","_scrollPosition","_overhang","anchorSize","undefined","anchorLeadingMargin","anchorTrailingMargin","anchorErr","_scrollError","margin","extentErr","_calculateError","_reflow","_lastVisible","_updateScrollSize","_setPositionFromPin","_updateVisibleIndices","_emitScrollSize","_emitRange","_emitChildPositions","_emitScrollError","_resetReflowState","_getItemPosition","_positionDim","_secondaryPositionDim","_getItemSize","_secondarySizeDim","_viewDim2Changed"],"sources":["../src/layouts/flow.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {SizeCache} from './shared/SizeCache.js';\nimport {BaseLayout, dim1} from './shared/BaseLayout.js';\nimport {\n  Positions,\n  Size,\n  Margins,\n  margin,\n  ScrollDirection,\n  offsetAxis,\n  ChildMeasurements,\n  BaseLayoutConfig,\n} from './shared/Layout.js';\n\ntype ItemBounds = {\n  pos: number;\n  size: number;\n};\n\ntype FlowLayoutConstructor = {\n  prototype: FlowLayout;\n  new (config?: BaseLayoutConfig): FlowLayout;\n};\n\ntype FlowLayoutSpecifier = BaseLayoutConfig & {\n  type: FlowLayoutConstructor;\n};\n\ntype FlowLayoutSpecifierFactory = (\n  config?: BaseLayoutConfig\n) => FlowLayoutSpecifier;\n\nexport const flow: FlowLayoutSpecifierFactory = (config?: BaseLayoutConfig) =>\n  Object.assign(\n    {\n      type: FlowLayout,\n    },\n    config\n  );\n\nfunction leadingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\n\nfunction trailingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\n\nfunction offset(direction: ScrollDirection): offsetAxis {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\n\nfunction collapseMargins(a: number, b: number): number {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\n\nclass MetricsCache {\n  private _childSizeCache = new SizeCache();\n  private _marginSizeCache = new SizeCache();\n  private _metricsCache: Map<number, Size & Margins> = new Map();\n\n  update(metrics: {[key: number]: Size & Margins}, direction: ScrollDirection) {\n    const marginsToUpdate: Set<number> = new Set();\n    Object.keys(metrics).forEach((key) => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      const a = this._metricsCache.get(k)?.[leadingMargin(direction)] || 0;\n      const b = this._metricsCache.get(k - 1)?.[trailingMargin(direction)] || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n\n  get averageChildSize(): number {\n    return this._childSizeCache.averageSize;\n  }\n\n  get totalChildSize(): number {\n    return this._childSizeCache.totalSize;\n  }\n\n  get averageMarginSize(): number {\n    return this._marginSizeCache.averageSize;\n  }\n\n  get totalMarginSize(): number {\n    return this._marginSizeCache.totalSize;\n  }\n\n  getLeadingMarginValue(index: number, direction: ScrollDirection) {\n    return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;\n  }\n\n  getChildSize(index: number) {\n    return this._childSizeCache.getSize(index);\n  }\n\n  getMarginSize(index: number) {\n    return this._marginSizeCache.getSize(index);\n  }\n\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n}\n\nexport class FlowLayout extends BaseLayout<BaseLayoutConfig> {\n  /**\n   * Initial estimate of item size\n   */\n  _itemSize: Size = {width: 100, height: 100};\n\n  /**\n   * Indices of children mapped to their (position and length) in the scrolling\n   * direction. Used to keep track of children that are in range.\n   */\n  _physicalItems: Map<number, ItemBounds> = new Map();\n\n  /**\n   * Used in tandem with _physicalItems to track children in range across\n   * reflows.\n   */\n  _newPhysicalItems: Map<number, ItemBounds> = new Map();\n\n  /**\n   * Width and height of children by their index.\n   */\n  _metricsCache = new MetricsCache();\n\n  /**\n   * anchorIdx is the anchor around which we reflow. It is designed to allow\n   * jumping to any point of the scroll size. We choose it once and stick with\n   * it until stable. _first and _last are deduced around it.\n   */\n  _anchorIdx: number | null = null;\n\n  /**\n   * Position in the scrolling direction of the anchor child.\n   */\n  _anchorPos: number | null = null;\n\n  /**\n   * Whether all children in range were in range during the previous reflow.\n   */\n  _stable = true;\n\n  private _measureChildren = true;\n\n  _estimate = true;\n\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n\n  // })\n\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n\n  get measureChildren() {\n    return this._measureChildren;\n  }\n\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes: ChildMeasurements) {\n    this._metricsCache.update(sizes as Size & Margins, this.direction);\n    // if (this._nMeasured) {\n    // this._updateItemSize();\n    this._scheduleReflow();\n    // }\n  }\n\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n\n  _getPhysicalItem(idx: number): ItemBounds | undefined {\n    return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);\n  }\n\n  _getSize(idx: number): number | undefined {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n\n  _getAverageSize(): number {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n\n  _estimatePosition(idx: number): number {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return (\n        c.averageMarginSize +\n        idx * (c.averageMarginSize + this._getAverageSize())\n      );\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return (\n          refItem!.pos -\n          (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n          (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize)\n        );\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return (\n          refItem!.pos +\n          (c.getChildSize(this._last) || c.averageChildSize) +\n          (c.getMarginSize(this._last) || c.averageMarginSize) +\n          delta * (c.averageChildSize + c.averageMarginSize)\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx: number): number {\n    const item = this._getPhysicalItem(idx);\n    const {averageMarginSize} = this._metricsCache;\n    return idx === 0\n      ? this._metricsCache.getMarginSize(0) ?? averageMarginSize\n      : item\n      ? item.pos\n      : this._estimatePosition(idx);\n  }\n\n  _calculateAnchor(lower: number, upper: number): number {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(\n      0,\n      Math.min(\n        this.items.length - 1,\n        Math.floor((lower + upper) / 2 / this._delta)\n      )\n    );\n  }\n\n  _getAnchor(lower: number, upper: number): number {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n\n    const firstItem = this._getPhysicalItem(this._first),\n      lastItem = this._getPhysicalItem(this._last),\n      firstMin = firstItem!.pos,\n      lastMin = lastItem!.pos,\n      lastMax = lastMin + this._metricsCache.getChildSize(this._last)!;\n\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate!.pos + this._metricsCache.getChildSize(candidateIdx)!;\n    }\n    return candidateIdx;\n  }\n\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n\n    // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n\n    // If we have a pinned item, we anchor on it\n    if (this.pin !== null) {\n      const {index} = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n\n    // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n\n    // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n\n    const anchorLeadingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx) ??\n      this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx + 1) ??\n      this._metricsCache.averageMarginSize;\n\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n\n    // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n    let anchorErr = 0;\n\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n\n    items.set(this._anchorIdx, {pos: this._anchorPos, size: anchorSize});\n\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, {pos, size});\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, {pos, size});\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n\n    // This handles the cases where we were relying on estimated sizes.\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach((item) => (item.pos -= extentErr));\n      this._scrollError += extentErr;\n    }\n\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n\n  _calculateError(): number {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return (\n        this._physicalMax -\n        this._scrollSize +\n        (this.items.length - 1 - this._last) * this._delta\n      );\n    }\n    return 0;\n  }\n\n  // TODO: Can this be made to inherit from base, with proper hooks?\n  _reflow() {\n    const {_first, _last, _scrollSize, _firstVisible, _lastVisible} = this;\n\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n\n    if (this._scrollSize !== _scrollSize) {\n      this._emitScrollSize();\n    }\n\n    if (\n      this._first !== _first ||\n      this._last !== _last ||\n      this._firstVisible !== _firstVisible ||\n      this._lastVisible !== _lastVisible\n    ) {\n      this._emitRange();\n    }\n\n    if (!(this._first === -1 && this._last === -1)) {\n      this._emitChildPositions();\n    }\n\n    if (this._scrollError !== 0) {\n      this._emitScrollError();\n    }\n\n    if (\n      (this._first === -1 && this._last == -1) ||\n      (this._first === _first && this._last === _last)\n    ) {\n      this._resetReflowState();\n    }\n  }\n\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n\n  _updateScrollSize() {\n    const {averageMarginSize} = this._metricsCache;\n    this._scrollSize = Math.max(\n      1,\n      this.items.length * (averageMarginSize + this._getAverageSize()) +\n        averageMarginSize\n    );\n  }\n\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  protected get _delta(): number {\n    const {averageMarginSize} = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx: number): Positions {\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -(\n        this._metricsCache.getLeadingMarginValue(idx, this.direction) ??\n        this._metricsCache.averageMarginSize\n      ),\n    } as Positions;\n  }\n\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx: number): Size {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n    } as Size;\n  }\n\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}