{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nexport class FilterExpressionTree {\n  constructor(key) {\n    this.key = key;\n    this.operands = [];\n  }\n  get empty() {\n    return this.operands.length < 1;\n  }\n  get length() {\n    return this.operands.length;\n  }\n  get all() {\n    return Array.from(this.iterator());\n  }\n  get ands() {\n    return this.operands.filter(each => each.criteria === 'and');\n  }\n  get ors() {\n    return this.operands.filter(each => each.criteria === 'or');\n  }\n  has(expression) {\n    return this.operands.includes(expression);\n  }\n  add(expression) {\n    if (!expression.criteria) {\n      expression.criteria = 'and';\n    }\n    if (this.operands.includes(expression)) {\n      return this;\n    }\n    this.operands.push(expression);\n    return this;\n  }\n  remove(expression) {\n    this.operands = this.operands.filter(each => each !== expression);\n    return this;\n  }\n  *iterator() {\n    for (const operand of this.operands) {\n      yield operand;\n    }\n  }\n  [Symbol.iterator]() {\n    return this.iterator();\n  }\n}","map":{"version":3,"names":["FilterExpressionTree","constructor","key","operands","empty","length","all","Array","from","iterator","ands","filter","each","criteria","ors","has","expression","includes","add","push","remove","operand","Symbol"],"sources":["../../../../src/operations/filter/tree.ts"],"sourcesContent":["import type { Keys } from '../../internal/types.js';\nimport type { FilterExpression } from './types.js';\n\nexport class FilterExpressionTree<T> {\n  protected operands: Array<FilterExpression<T>> = [];\n\n  constructor(public key: Keys<T>) {}\n\n  public get empty() {\n    return this.operands.length < 1;\n  }\n\n  public get length() {\n    return this.operands.length;\n  }\n\n  public get all() {\n    return Array.from(this.iterator());\n  }\n\n  public get ands() {\n    return this.operands.filter(each => each.criteria === 'and');\n  }\n\n  public get ors() {\n    return this.operands.filter(each => each.criteria === 'or');\n  }\n\n  public has(expression: FilterExpression<T>) {\n    return this.operands.includes(expression);\n  }\n\n  public add(expression: FilterExpression<T>) {\n    if (!expression.criteria) {\n      expression.criteria = 'and';\n    }\n\n    if (this.operands.includes(expression)) {\n      return this;\n    }\n\n    this.operands.push(expression);\n    return this;\n  }\n\n  public remove(expression: FilterExpression<T>) {\n    this.operands = this.operands.filter(each => each !== expression);\n    return this;\n  }\n\n  protected *iterator() {\n    for (const operand of this.operands) {\n      yield operand;\n    }\n  }\n\n  public [Symbol.iterator]() {\n    return this.iterator();\n  }\n}\n"],"mappings":";AAGA,OAAM,MAAOA,oBAAoB;EAG/BC,YAAmBC,GAAY;IAAZ,KAAAA,GAAG,GAAHA,GAAG;IAFZ,KAAAC,QAAQ,GAA+B,EAAE;EAEjB;EAElC,IAAWC,KAAKA,CAAA;IACd,OAAO,IAAI,CAACD,QAAQ,CAACE,MAAM,GAAG,CAAC;EACjC;EAEA,IAAWA,MAAMA,CAAA;IACf,OAAO,IAAI,CAACF,QAAQ,CAACE,MAAM;EAC7B;EAEA,IAAWC,GAAGA,CAAA;IACZ,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE,CAAC;EACpC;EAEA,IAAWC,IAAIA,CAAA;IACb,OAAO,IAAI,CAACP,QAAQ,CAACQ,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,QAAQ,KAAK,KAAK,CAAC;EAC9D;EAEA,IAAWC,GAAGA,CAAA;IACZ,OAAO,IAAI,CAACX,QAAQ,CAACQ,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,QAAQ,KAAK,IAAI,CAAC;EAC7D;EAEOE,GAAGA,CAACC,UAA+B;IACxC,OAAO,IAAI,CAACb,QAAQ,CAACc,QAAQ,CAACD,UAAU,CAAC;EAC3C;EAEOE,GAAGA,CAACF,UAA+B;IACxC,IAAI,CAACA,UAAU,CAACH,QAAQ,EAAE;MACxBG,UAAU,CAACH,QAAQ,GAAG,KAAK;;IAG7B,IAAI,IAAI,CAACV,QAAQ,CAACc,QAAQ,CAACD,UAAU,CAAC,EAAE;MACtC,OAAO,IAAI;;IAGb,IAAI,CAACb,QAAQ,CAACgB,IAAI,CAACH,UAAU,CAAC;IAC9B,OAAO,IAAI;EACb;EAEOI,MAAMA,CAACJ,UAA+B;IAC3C,IAAI,CAACb,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACQ,MAAM,CAACC,IAAI,IAAIA,IAAI,KAAKI,UAAU,CAAC;IACjE,OAAO,IAAI;EACb;EAEU,CAACP,QAAQA,CAAA;IACjB,KAAK,MAAMY,OAAO,IAAI,IAAI,CAAClB,QAAQ,EAAE;MACnC,MAAMkB,OAAO;;EAEjB;EAEO,CAACC,MAAM,CAACb,QAAQ,IAAC;IACtB,OAAO,IAAI,CAACA,QAAQ,EAAE;EACxB"},"metadata":{},"sourceType":"module","externalDependencies":[]}