{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { ValueNotifier } from '../value-notifier.js';\nexport class ContextProviderEvent extends Event {\n  /**\n   *\n   * @param context the context which this provider can provide\n   */\n  constructor(context) {\n    super('context-provider', {\n      bubbles: true,\n      composed: true\n    });\n    this.context = context;\n  }\n}\n/**\n * A ReactiveController which can add context provider behavior to a\n * custom-element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n */\nexport class ContextProvider extends ValueNotifier {\n  constructor(host, context, initialValue) {\n    super(initialValue);\n    this.host = host;\n    this.context = context;\n    this.onContextRequest = ev => {\n      // Only call the callback if the context matches.\n      // Also, in case an element is a consumer AND a provider\n      // of the same context, we want to avoid the element to self-register.\n      // The check on composedPath (as opposed to ev.target) is to cover cases\n      // where the consumer is in the shadowDom of the provider (in which case,\n      // event.target === this.host because of event retargeting).\n      if (ev.context !== this.context || ev.composedPath()[0] === this.host) {\n        return;\n      }\n      ev.stopPropagation();\n      this.addCallback(ev.callback, ev.subscribe);\n    };\n    this.attachListeners();\n    this.host.addController(this);\n  }\n  attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n  }\n  hostConnected() {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context));\n  }\n}","map":{"version":3,"names":["ValueNotifier","ContextProviderEvent","Event","constructor","context","bubbles","composed","ContextProvider","host","initialValue","onContextRequest","ev","composedPath","stopPropagation","addCallback","callback","subscribe","attachListeners","addController","addEventListener","hostConnected","dispatchEvent"],"sources":["../../../src/lib/controllers/context-provider.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ContextRequestEvent} from '../context-request-event.js';\nimport {Context, ContextType} from '../create-context.js';\nimport {ValueNotifier} from '../value-notifier.js';\nimport {ReactiveController, ReactiveElement} from 'lit';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    /**\n     * A 'context-provider' event can be emitted by any element which hosts\n     * a context provider to indicate it is available for use.\n     */\n    'context-provider': ContextProviderEvent<Context<unknown, unknown>>;\n  }\n}\n\nexport class ContextProviderEvent<\n  C extends Context<unknown, unknown>\n> extends Event {\n  /**\n   *\n   * @param context the context which this provider can provide\n   */\n  public constructor(public readonly context: C) {\n    super('context-provider', {bubbles: true, composed: true});\n  }\n}\n\n/**\n * A ReactiveController which can add context provider behavior to a\n * custom-element.\n *\n * This controller simply listens to the `context-request` event when\n * the host is connected to the DOM and registers the received callbacks\n * against its observable Context implementation.\n */\nexport class ContextProvider<T extends Context<unknown, unknown>>\n  extends ValueNotifier<ContextType<T>>\n  implements ReactiveController\n{\n  constructor(\n    protected host: ReactiveElement,\n    private context: T,\n    initialValue?: ContextType<T>\n  ) {\n    super(initialValue);\n    this.attachListeners();\n    this.host.addController(this);\n  }\n\n  public onContextRequest = (\n    ev: ContextRequestEvent<Context<unknown, unknown>>\n  ): void => {\n    // Only call the callback if the context matches.\n    // Also, in case an element is a consumer AND a provider\n    // of the same context, we want to avoid the element to self-register.\n    // The check on composedPath (as opposed to ev.target) is to cover cases\n    // where the consumer is in the shadowDom of the provider (in which case,\n    // event.target === this.host because of event retargeting).\n    if (ev.context !== this.context || ev.composedPath()[0] === this.host) {\n      return;\n    }\n    ev.stopPropagation();\n    this.addCallback(ev.callback, ev.subscribe);\n  };\n\n  private attachListeners() {\n    this.host.addEventListener('context-request', this.onContextRequest);\n  }\n\n  hostConnected(): void {\n    // emit an event to signal a provider is available for this context\n    this.host.dispatchEvent(new ContextProviderEvent(this.context));\n  }\n}\n"],"mappings":"AAAA;;;;;AAQA,SAAQA,aAAa,QAAO,sBAAsB;AAalD,OAAM,MAAOC,oBAEX,SAAQC,KAAK;EACb;;;;EAIAC,YAAmCC,OAAU;IAC3C,KAAK,CAAC,kBAAkB,EAAE;MAACC,OAAO,EAAE,IAAI;MAAEC,QAAQ,EAAE;IAAI,CAAC,CAAC;IADzB,KAAAF,OAAO,GAAPA,OAAO;EAE1C;;AAGF;;;;;;;;AAQA,OAAM,MAAOG,eACX,SAAQP,aAA6B;EAGrCG,YACYK,IAAqB,EACvBJ,OAAU,EAClBK,YAA6B;IAE7B,KAAK,CAACA,YAAY,CAAC;IAJT,KAAAD,IAAI,GAAJA,IAAI;IACN,KAAAJ,OAAO,GAAPA,OAAO;IAQV,KAAAM,gBAAgB,GACrBC,EAAkD,IAC1C;MACR;MACA;MACA;MACA;MACA;MACA;MACA,IAAIA,EAAE,CAACP,OAAO,KAAK,IAAI,CAACA,OAAO,IAAIO,EAAE,CAACC,YAAY,EAAE,CAAC,CAAC,CAAC,KAAK,IAAI,CAACJ,IAAI,EAAE;QACrE;;MAEFG,EAAE,CAACE,eAAe,EAAE;MACpB,IAAI,CAACC,WAAW,CAACH,EAAE,CAACI,QAAQ,EAAEJ,EAAE,CAACK,SAAS,CAAC;IAC7C,CAAC;IAlBC,IAAI,CAACC,eAAe,EAAE;IACtB,IAAI,CAACT,IAAI,CAACU,aAAa,CAAC,IAAI,CAAC;EAC/B;EAkBQD,eAAeA,CAAA;IACrB,IAAI,CAACT,IAAI,CAACW,gBAAgB,CAAC,iBAAiB,EAAE,IAAI,CAACT,gBAAgB,CAAC;EACtE;EAEAU,aAAaA,CAAA;IACX;IACA,IAAI,CAACZ,IAAI,CAACa,aAAa,CAAC,IAAIpB,oBAAoB,CAAC,IAAI,CAACG,OAAO,CAAC,CAAC;EACjE"},"metadata":{},"sourceType":"module","externalDependencies":[]}