{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { html, LitElement, nothing } from 'lit';\nimport { property, query, queryAssignedNodes, state } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { guard } from 'lit/directives/guard.js';\nimport { themes } from '../../theming/theming-decorator.js';\nimport { watch } from '../common/decorators/watch.js';\nimport { EventEmitterMixin } from '../common/mixins/event-emitter.js';\nimport { SizableMixin } from '../common/mixins/sizable.js';\nimport { clamp, isLTR } from '../common/util.js';\nimport { styles } from './rating.base.css.js';\nimport { styles as bootstrap } from './rating.bootstrap.css.js';\nimport { styles as fluent } from './rating.fluent.css.js';\nimport { styles as indigo } from './rating.indigo.css.js';\nimport { defineComponents } from '../common/definitions/defineComponents.js';\nimport IgcRatingSymbolComponent from './rating-symbol.js';\nimport IgcIconComponent from '../icon/icon.js';\ndefineComponents(IgcRatingSymbolComponent, IgcIconComponent);\nlet IgcRatingComponent = class IgcRatingComponent extends SizableMixin(EventEmitterMixin(LitElement)) {\n  get isInteractive() {\n    return !(this.readonly || this.disabled);\n  }\n  get hasProjectedSymbols() {\n    return this.ratingSymbols.length > 0;\n  }\n  get valueText() {\n    const value = this.round(this.value);\n    return this.valueFormat ? this.valueFormat.replace(/\\{0\\}/gm, `${value}`).replace(/\\{1\\}/gm, `${this.max}`) : `${value} of ${this.max}`;\n  }\n  handleMaxChange() {\n    this.hasProjectedSymbols ? this.max = this.ratingSymbols.length : this.max = Math.max(0, this.max);\n    if (this.max < this.value) {\n      this.value = this.max;\n    }\n  }\n  handleValueChange() {\n    this.value = clamp(this.value, 0, this.max);\n  }\n  handlePrecisionChange() {\n    this.step = !this.single ? clamp(this.step, 0.001, 1) : 1;\n  }\n  handleSelectionChange() {\n    if (this.single) {\n      this.step = 1;\n      this.value = Math.ceil(this.value);\n    }\n  }\n  constructor() {\n    super();\n    this.ratingSymbols = [];\n    this.hoverValue = -1;\n    this.hoverState = false;\n    this.max = 5;\n    this.step = 1;\n    this.value = 0;\n    this.disabled = false;\n    this.hoverPreview = false;\n    this.readonly = false;\n    this.single = false;\n    this.addEventListener('keydown', this.handleKeyDown);\n  }\n  handleClick({\n    clientX\n  }) {\n    if (!this.isInteractive) {\n      return;\n    }\n    const value = this.calcNewValue(clientX);\n    this.value === value ? this.value = 0 : this.value = value;\n    this.emitEvent('igcChange', {\n      detail: this.value\n    });\n  }\n  handleMouseMove({\n    clientX\n  }) {\n    if (!this.isInteractive) {\n      return;\n    }\n    const value = this.calcNewValue(clientX);\n    if (this.hoverValue !== value) {\n      this.hoverValue = value;\n      this.emitEvent('igcHover', {\n        detail: this.hoverValue\n      });\n    }\n  }\n  handleMouseEnter() {\n    if (this.isInteractive) {\n      this.hoverState = true;\n    }\n  }\n  handleMouseLeave() {\n    if (this.isInteractive) {\n      this.hoverState = false;\n    }\n  }\n  handleKeyDown({\n    key\n  }) {\n    if (!this.isInteractive) {\n      return;\n    }\n    let result = this.value;\n    const ltr = isLTR(this);\n    switch (key) {\n      case 'ArrowUp':\n      case 'ArrowRight':\n        result += ltr ? this.step : -this.step;\n        break;\n      case 'ArrowDown':\n      case 'ArrowLeft':\n        result -= ltr ? this.step : -this.step;\n        break;\n      case 'Home':\n        result = this.step;\n        break;\n      case 'End':\n        result = this.max;\n        break;\n      default:\n        return;\n    }\n    this.value = clamp(result, 0, this.max);\n    if (result === this.value) {\n      this.emitEvent('igcChange', {\n        detail: this.value\n      });\n    }\n  }\n  handleSlotChange(event) {\n    const slot = event.target;\n    this.ratingSymbols = slot.assignedElements().filter(el => el instanceof IgcRatingSymbolComponent);\n    if (this.hasProjectedSymbols) {\n      this.max = this.ratingSymbols.length;\n    }\n    this.requestUpdate();\n  }\n  calcNewValue(x) {\n    const {\n      width,\n      left,\n      right\n    } = this.container.getBoundingClientRect();\n    const percent = isLTR(this) ? (x - left) / width : (right - x) / width;\n    const value = this.round(this.max * percent + this.step / 2);\n    return clamp(value, this.step, this.max);\n  }\n  getPrecision(num) {\n    const [_, decimal] = num.toString().split('.');\n    return decimal ? decimal.length : 0;\n  }\n  round(value) {\n    value = Math.round(value / this.step) * this.step;\n    return Number(value.toFixed(this.getPrecision(this.step)));\n  }\n  clipSymbol(index, isLTR = true) {\n    const value = this.hoverState ? this.hoverValue : this.value;\n    const progress = index + 1 - value;\n    const exclusive = progress === 0 || this.value === index + 1 ? 0 : 1;\n    const selection = this.single ? exclusive : progress;\n    const activate = p => clamp(p * 100, 0, 100);\n    const forward = `inset(0 ${activate(isLTR ? selection : 1 - selection)}% 0 0)`;\n    const backward = `inset(0 0 0 ${activate(isLTR ? 1 - selection : selection)}%)`;\n    return {\n      backward: isLTR ? backward : forward,\n      forward: isLTR ? forward : backward\n    };\n  }\n  stepUp(n = 1) {\n    this.value += this.round(n * this.step);\n  }\n  stepDown(n = 1) {\n    this.value -= this.round(n * this.step);\n  }\n  *renderSymbols() {\n    const ltr = isLTR(this);\n    for (let i = 0; i < this.max; i++) {\n      const {\n        forward,\n        backward\n      } = this.clipSymbol(i, ltr);\n      yield html`<igc-rating-symbol exportparts=\"symbol, full, empty\">\n        <igc-icon\n          collection=\"internal\"\n          name=\"star\"\n          style=${styleMap({\n        clipPath: forward\n      })}\n        ></igc-icon>\n        <igc-icon\n          collection=\"internal\"\n          name=\"star_border\"\n          style=${styleMap({\n        clipPath: backward\n      })}\n          slot=\"empty\"\n        ></igc-icon>\n      </igc-rating-symbol>`;\n    }\n  }\n  clipProjected() {\n    if (this.hasProjectedSymbols) {\n      const ltr = isLTR(this);\n      this.ratingSymbols.forEach((symbol, i) => {\n        var _a, _b;\n        const full = (_a = symbol.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector('[part=\"symbol full\"]');\n        const empty = (_b = symbol.shadowRoot) === null || _b === void 0 ? void 0 : _b.querySelector('[part=\"symbol empty\"]');\n        const {\n          forward,\n          backward\n        } = this.clipSymbol(i, ltr);\n        if (full) {\n          full.style.clipPath = forward;\n        }\n        if (empty) {\n          empty.style.clipPath = backward;\n        }\n      });\n    }\n  }\n  render() {\n    const props = [this.value, this.hoverValue, this.max, this.step, this.single, this.hoverState, this.ratingSymbols];\n    return html`\n      <label part=\"label\" id=\"rating-label\" ?hidden=${!this.label}\n        >${this.label}</label\n      >\n      <div\n        part=\"base\"\n        role=\"slider\"\n        tabindex=${ifDefined(this.disabled ? undefined : 0)}\n        aria-labelledby=\"rating-label\"\n        aria-valuemin=\"0\"\n        aria-valuenow=${this.value}\n        aria-valuemax=${this.max}\n        aria-valuetext=${this.valueText}\n      >\n        <div\n          aria-hidden=\"true\"\n          part=\"symbols\"\n          @click=${this.handleClick}\n          @mouseenter=${this.hoverPreview ? this.handleMouseEnter : nothing}\n          @mouseleave=${this.hoverPreview ? this.handleMouseLeave : nothing}\n          @mousemove=${this.hoverPreview ? this.handleMouseMove : nothing}\n        >\n          <slot name=\"symbol\" @slotchange=${this.handleSlotChange}>\n            ${guard(props, () => {\n      this.clipProjected();\n      return this.renderSymbols();\n    })}\n          </slot>\n        </div>\n        <label part=\"value-label\" ?hidden=${this.valueLabel.length === 0}>\n          <slot name=\"value-label\"></slot>\n        </label>\n      </div>\n    `;\n  }\n};\nIgcRatingComponent.tagName = 'igc-rating';\nIgcRatingComponent.styles = [styles];\n__decorate([query('[part=\"symbols\"]', true)], IgcRatingComponent.prototype, \"container\", void 0);\n__decorate([queryAssignedNodes({\n  slot: 'value-label',\n  flatten: true\n})], IgcRatingComponent.prototype, \"valueLabel\", void 0);\n__decorate([state()], IgcRatingComponent.prototype, \"hoverValue\", void 0);\n__decorate([state()], IgcRatingComponent.prototype, \"hoverState\", void 0);\n__decorate([property({\n  type: Number\n})], IgcRatingComponent.prototype, \"max\", void 0);\n__decorate([property({\n  type: Number\n})], IgcRatingComponent.prototype, \"step\", void 0);\n__decorate([property()], IgcRatingComponent.prototype, \"name\", void 0);\n__decorate([property()], IgcRatingComponent.prototype, \"label\", void 0);\n__decorate([property({\n  attribute: 'value-format'\n})], IgcRatingComponent.prototype, \"valueFormat\", void 0);\n__decorate([property({\n  type: Number\n})], IgcRatingComponent.prototype, \"value\", void 0);\n__decorate([property({\n  type: Boolean,\n  reflect: true\n})], IgcRatingComponent.prototype, \"disabled\", void 0);\n__decorate([property({\n  type: Boolean,\n  reflect: true,\n  attribute: 'hover-preview'\n})], IgcRatingComponent.prototype, \"hoverPreview\", void 0);\n__decorate([property({\n  type: Boolean,\n  reflect: true\n})], IgcRatingComponent.prototype, \"readonly\", void 0);\n__decorate([property({\n  type: Boolean\n})], IgcRatingComponent.prototype, \"single\", void 0);\n__decorate([watch('max')], IgcRatingComponent.prototype, \"handleMaxChange\", null);\n__decorate([watch('value')], IgcRatingComponent.prototype, \"handleValueChange\", null);\n__decorate([watch('step')], IgcRatingComponent.prototype, \"handlePrecisionChange\", null);\n__decorate([watch('single')], IgcRatingComponent.prototype, \"handleSelectionChange\", null);\nIgcRatingComponent = __decorate([themes({\n  fluent,\n  bootstrap,\n  indigo\n})], IgcRatingComponent);\nexport default IgcRatingComponent;","map":{"version":3,"names":["html","LitElement","nothing","property","query","queryAssignedNodes","state","ifDefined","styleMap","guard","themes","watch","EventEmitterMixin","SizableMixin","clamp","isLTR","styles","bootstrap","fluent","indigo","defineComponents","IgcRatingSymbolComponent","IgcIconComponent","IgcRatingComponent","isInteractive","readonly","disabled","hasProjectedSymbols","ratingSymbols","length","valueText","value","round","valueFormat","replace","max","handleMaxChange","Math","handleValueChange","handlePrecisionChange","step","single","handleSelectionChange","ceil","constructor","hoverValue","hoverState","hoverPreview","addEventListener","handleKeyDown","handleClick","clientX","calcNewValue","emitEvent","detail","handleMouseMove","handleMouseEnter","handleMouseLeave","key","result","ltr","handleSlotChange","event","slot","target","assignedElements","filter","el","requestUpdate","x","width","left","right","container","getBoundingClientRect","percent","getPrecision","num","_","decimal","toString","split","Number","toFixed","clipSymbol","index","progress","exclusive","selection","activate","p","forward","backward","stepUp","n","stepDown","renderSymbols","i","clipPath","clipProjected","forEach","symbol","full","_a","shadowRoot","querySelector","empty","_b","style","render","props","label","undefined","valueLabel","tagName","__decorate","flatten","type","attribute","Boolean","reflect"],"sources":["../../../src/components/rating/rating.ts"],"sourcesContent":["import { html, LitElement, nothing } from 'lit';\nimport { property, query, queryAssignedNodes, state } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport { styleMap } from 'lit/directives/style-map.js';\nimport { guard } from 'lit/directives/guard.js';\nimport { themes } from '../../theming/theming-decorator.js';\nimport { watch } from '../common/decorators/watch.js';\nimport { Constructor } from '../common/mixins/constructor.js';\nimport { EventEmitterMixin } from '../common/mixins/event-emitter.js';\nimport { SizableMixin } from '../common/mixins/sizable.js';\nimport { clamp, isLTR } from '../common/util.js';\nimport { styles } from './rating.base.css.js';\nimport { styles as bootstrap } from './rating.bootstrap.css.js';\nimport { styles as fluent } from './rating.fluent.css.js';\nimport { styles as indigo } from './rating.indigo.css.js';\n\nimport { defineComponents } from '../common/definitions/defineComponents.js';\nimport IgcRatingSymbolComponent from './rating-symbol.js';\nimport IgcIconComponent from '../icon/icon.js';\n\ndefineComponents(IgcRatingSymbolComponent, IgcIconComponent);\n\nexport interface IgcRatingEventMap {\n  igcChange: CustomEvent<number>;\n  igcHover: CustomEvent<number>;\n}\n\n/**\n * Rating provides insight regarding others' opinions and experiences,\n * and can allow the user to submit a rating of their own\n *\n * @element igc-rating\n *\n * @fires igcChange - Emitted when the value of the control changes.\n * @fires igcHover - Emitted when hover is enabled and the user mouses over a symbol of the rating.\n *\n * @csspart base - The main wrapper which holds all of the rating elements.\n * @csspart label - The label part.\n * @csspart value-label - The value label part.\n * @csspart symbols - A wrapper for all rating symbols.\n * @csspart symbol - The part of the encapsulated default symbol.\n * @csspart full - The part of the encapsulated full symbols.\n * @csspart empty - The part of the encapsulated empty symbols.\n *\n * @cssproperty --symbol-size - The size of the symbols.\n * @cssproperty --symbol-full-color - The color of the filled symbol.\n * @cssproperty --symbol-empty-color - The color of the empty symbol.\n * @cssproperty --symbol-full-filter - The filter(s) used for the filled symbol.\n * @cssproperty --symbol-empty-filter - The filter(s) used for the empty symbol.\n */\n@themes({ fluent, bootstrap, indigo })\nexport default class IgcRatingComponent extends SizableMixin(\n  EventEmitterMixin<IgcRatingEventMap, Constructor<LitElement>>(LitElement)\n) {\n  public static readonly tagName = 'igc-rating';\n\n  public static styles = [styles];\n\n  protected ratingSymbols: Array<IgcRatingSymbolComponent> = [];\n\n  @query('[part=\"symbols\"]', true)\n  protected container!: HTMLElement;\n\n  @queryAssignedNodes({ slot: 'value-label', flatten: true })\n  protected valueLabel!: Array<Node>;\n\n  @state()\n  protected hoverValue = -1;\n\n  @state()\n  protected hoverState = false;\n\n  protected get isInteractive() {\n    return !(this.readonly || this.disabled);\n  }\n\n  protected get hasProjectedSymbols() {\n    return this.ratingSymbols.length > 0;\n  }\n\n  protected get valueText() {\n    // Skip IEEE 754 representation for screen readers\n    const value = this.round(this.value);\n\n    return this.valueFormat\n      ? this.valueFormat\n          .replace(/\\{0\\}/gm, `${value}`)\n          .replace(/\\{1\\}/gm, `${this.max}`)\n      : `${value} of ${this.max}`;\n  }\n\n  /**\n   * The maximum value for the rating.\n   *\n   * If there are projected symbols, the maximum value will be resolved\n   * based on the number of symbols.\n   * @attr\n   */\n  @property({ type: Number })\n  public max = 5;\n\n  /**\n   * The minimum value change allowed.\n   *\n   * Valid values are in the interval between 0 and 1 inclusive.\n   * @attr\n   */\n  @property({ type: Number })\n  public step = 1;\n\n  /**\n   * The name attribute of the control\n   * @attr\n   */\n  @property()\n  public name!: string;\n\n  /**\n   * The label of the control.\n   * @attr\n   */\n  @property()\n  public label!: string;\n\n  /**\n   * A format string which sets aria-valuetext. Instances of '{0}' will be replaced\n   * with the current value of the control and instances of '{1}' with the maximum value for the control.\n   *\n   * Important for screen-readers and useful for localization.\n   * @attr value-format\n   */\n  @property({ attribute: 'value-format' })\n  public valueFormat!: string;\n\n  /**\n   * The current value of the component\n   * @attr\n   */\n  @property({ type: Number })\n  public value = 0;\n\n  /**\n   * Sets the disabled state of the component\n   * @attr\n   */\n  @property({ type: Boolean, reflect: true })\n  public disabled = false;\n\n  /**\n   * Sets hover preview behavior for the component\n   * @attr\n   */\n  @property({ type: Boolean, reflect: true, attribute: 'hover-preview' })\n  public hoverPreview = false;\n\n  /**\n   * Sets the readonly state of the component\n   * @attr\n   */\n  @property({ type: Boolean, reflect: true })\n  public readonly = false;\n\n  /**\n   * Toggles single selection visual mode.\n   * @attr\n   */\n  @property({ type: Boolean })\n  public single = false;\n\n  @watch('max')\n  protected handleMaxChange() {\n    this.hasProjectedSymbols\n      ? (this.max = this.ratingSymbols.length)\n      : (this.max = Math.max(0, this.max));\n    if (this.max < this.value) {\n      this.value = this.max;\n    }\n  }\n\n  @watch('value')\n  protected handleValueChange() {\n    this.value = clamp(this.value, 0, this.max);\n  }\n\n  @watch('step')\n  protected handlePrecisionChange() {\n    this.step = !this.single ? clamp(this.step, 0.001, 1) : 1;\n  }\n\n  @watch('single')\n  protected handleSelectionChange() {\n    if (this.single) {\n      this.step = 1;\n      this.value = Math.ceil(this.value);\n    }\n  }\n\n  constructor() {\n    super();\n    this.addEventListener('keydown', this.handleKeyDown);\n  }\n\n  protected handleClick({ clientX }: MouseEvent) {\n    if (!this.isInteractive) {\n      return;\n    }\n\n    const value = this.calcNewValue(clientX);\n    this.value === value ? (this.value = 0) : (this.value = value);\n    this.emitEvent('igcChange', { detail: this.value });\n  }\n\n  protected handleMouseMove({ clientX }: MouseEvent) {\n    if (!this.isInteractive) {\n      return;\n    }\n\n    const value = this.calcNewValue(clientX);\n\n    if (this.hoverValue !== value) {\n      // Since mousemove spams a lot, only emit on a value change\n      this.hoverValue = value;\n      this.emitEvent('igcHover', { detail: this.hoverValue });\n    }\n  }\n\n  protected handleMouseEnter() {\n    if (this.isInteractive) {\n      this.hoverState = true;\n    }\n  }\n\n  protected handleMouseLeave() {\n    if (this.isInteractive) {\n      this.hoverState = false;\n    }\n  }\n\n  protected handleKeyDown({ key }: KeyboardEvent) {\n    if (!this.isInteractive) {\n      return;\n    }\n\n    let result = this.value;\n    const ltr = isLTR(this);\n\n    switch (key) {\n      case 'ArrowUp':\n      case 'ArrowRight':\n        result += ltr ? this.step : -this.step;\n        break;\n      case 'ArrowDown':\n      case 'ArrowLeft':\n        result -= ltr ? this.step : -this.step;\n        break;\n      case 'Home':\n        result = this.step;\n        break;\n      case 'End':\n        result = this.max;\n        break;\n      default:\n        return;\n    }\n\n    // Verify new value is in bounds and emit\n    this.value = clamp(result, 0, this.max);\n\n    if (result === this.value) {\n      this.emitEvent('igcChange', { detail: this.value });\n    }\n  }\n\n  protected handleSlotChange(event: Event) {\n    const slot = event.target as HTMLSlotElement;\n\n    this.ratingSymbols = slot\n      .assignedElements()\n      .filter(\n        (el) => el instanceof IgcRatingSymbolComponent\n      ) as IgcRatingSymbolComponent[];\n\n    if (this.hasProjectedSymbols) {\n      this.max = this.ratingSymbols.length;\n    }\n\n    this.requestUpdate();\n  }\n\n  protected calcNewValue(x: number) {\n    const { width, left, right } = this.container.getBoundingClientRect();\n    const percent = isLTR(this) ? (x - left) / width : (right - x) / width;\n    const value = this.round(this.max * percent + this.step / 2);\n\n    return clamp(value, this.step, this.max);\n  }\n\n  protected getPrecision(num: number) {\n    const [_, decimal] = num.toString().split('.');\n    return decimal ? decimal.length : 0;\n  }\n\n  protected round(value: number) {\n    value = Math.round(value / this.step) * this.step;\n    return Number(value.toFixed(this.getPrecision(this.step)));\n  }\n\n  protected clipSymbol(index: number, isLTR = true) {\n    const value = this.hoverState ? this.hoverValue : this.value;\n    const progress = index + 1 - value;\n    const exclusive = progress === 0 || this.value === index + 1 ? 0 : 1;\n    const selection = this.single ? exclusive : progress;\n    const activate = (p: number) => clamp(p * 100, 0, 100);\n\n    const forward = `inset(0 ${activate(\n      isLTR ? selection : 1 - selection\n    )}% 0 0)`;\n    const backward = `inset(0 0 0 ${activate(\n      isLTR ? 1 - selection : selection\n    )}%)`;\n\n    return {\n      backward: isLTR ? backward : forward,\n      forward: isLTR ? forward : backward,\n    };\n  }\n\n  /**\n   * Increments the value of the control by `n` steps multiplied by the\n   * step factor.\n   */\n  public stepUp(n = 1) {\n    this.value += this.round(n * this.step);\n  }\n\n  /**\n   * Decrements the value of the control by `n` steps multiplied by\n   * the step factor.\n   */\n  public stepDown(n = 1) {\n    this.value -= this.round(n * this.step);\n  }\n\n  protected *renderSymbols() {\n    const ltr = isLTR(this);\n    for (let i = 0; i < this.max; i++) {\n      const { forward, backward } = this.clipSymbol(i, ltr);\n      yield html`<igc-rating-symbol exportparts=\"symbol, full, empty\">\n        <igc-icon\n          collection=\"internal\"\n          name=\"star\"\n          style=${styleMap({ clipPath: forward })}\n        ></igc-icon>\n        <igc-icon\n          collection=\"internal\"\n          name=\"star_border\"\n          style=${styleMap({ clipPath: backward })}\n          slot=\"empty\"\n        ></igc-icon>\n      </igc-rating-symbol>`;\n    }\n  }\n\n  protected clipProjected() {\n    if (this.hasProjectedSymbols) {\n      const ltr = isLTR(this);\n      this.ratingSymbols.forEach((symbol: IgcRatingSymbolComponent, i) => {\n        const full = symbol.shadowRoot?.querySelector(\n          '[part=\"symbol full\"]'\n        ) as HTMLElement;\n\n        const empty = symbol.shadowRoot?.querySelector(\n          '[part=\"symbol empty\"]'\n        ) as HTMLElement;\n        const { forward, backward } = this.clipSymbol(i, ltr);\n\n        if (full) {\n          full.style.clipPath = forward;\n        }\n\n        if (empty) {\n          empty.style.clipPath = backward;\n        }\n      });\n    }\n  }\n\n  protected override render() {\n    const props = [\n      this.value,\n      this.hoverValue,\n      this.max,\n      this.step,\n      this.single,\n      this.hoverState,\n      this.ratingSymbols,\n    ];\n\n    return html`\n      <label part=\"label\" id=\"rating-label\" ?hidden=${!this.label}\n        >${this.label}</label\n      >\n      <div\n        part=\"base\"\n        role=\"slider\"\n        tabindex=${ifDefined(this.disabled ? undefined : 0)}\n        aria-labelledby=\"rating-label\"\n        aria-valuemin=\"0\"\n        aria-valuenow=${this.value}\n        aria-valuemax=${this.max}\n        aria-valuetext=${this.valueText}\n      >\n        <div\n          aria-hidden=\"true\"\n          part=\"symbols\"\n          @click=${this.handleClick}\n          @mouseenter=${this.hoverPreview ? this.handleMouseEnter : nothing}\n          @mouseleave=${this.hoverPreview ? this.handleMouseLeave : nothing}\n          @mousemove=${this.hoverPreview ? this.handleMouseMove : nothing}\n        >\n          <slot name=\"symbol\" @slotchange=${this.handleSlotChange}>\n            ${guard(props, () => {\n              this.clipProjected();\n              return this.renderSymbols();\n            })}\n          </slot>\n        </div>\n        <label part=\"value-label\" ?hidden=${this.valueLabel.length === 0}>\n          <slot name=\"value-label\"></slot>\n        </label>\n      </div>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'igc-rating': IgcRatingComponent;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}