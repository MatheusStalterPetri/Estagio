{"ast":null,"code":"const FLAGS = new Set('aACL09#&?');\nconst REGEX = new Map([['C', /(?!^$)/u], ['&', /[^\\p{Separator}]/u], ['a', /[\\p{Letter}\\d\\p{Separator}]/u], ['A', /[\\p{Letter}\\d]/u], ['?', /[\\p{Letter}\\p{Separator}]/u], ['L', /\\p{Letter}/u], ['0', /\\d/], ['9', /[\\d\\p{Separator}]/u], ['#', /[\\d\\-+]/]]);\nconst REQUIRED = new Set('0#LA&');\nconst replaceIMENumbers = string => {\n  return string.replace(/[０１２３４５６７８９]/g, num => ({\n    '１': '1',\n    '２': '2',\n    '３': '3',\n    '４': '4',\n    '５': '5',\n    '６': '6',\n    '７': '7',\n    '８': '8',\n    '９': '9',\n    '０': '0'\n  })[num]);\n};\nexport class MaskParser {\n  constructor(options = {\n    format: 'CCCCCCCCCC',\n    promptCharacter: '_'\n  }) {\n    this.literals = new Map();\n    this.options = options;\n  }\n  get literalPositions() {\n    this.getMaskLiterals();\n    return Array.from(this.literals.keys());\n  }\n  get escapedMask() {\n    this.getMaskLiterals();\n    return this._escapedMask;\n  }\n  get mask() {\n    return this.options.format;\n  }\n  set mask(value) {\n    this.options.format = value || this.options.format;\n    this.getMaskLiterals();\n  }\n  get prompt() {\n    return this.options.promptCharacter;\n  }\n  set prompt(value) {\n    this.options.promptCharacter = value ? value.substring(0, 1) : this.options.promptCharacter;\n  }\n  getMaskLiterals() {\n    this.literals.clear();\n    this._escapedMask = this.mask;\n    for (let i = 0, j = 0; i < this.mask.length; i++, j++) {\n      const [current, next] = [this.mask.charAt(i), this.mask.charAt(i + 1)];\n      if (current === '\\\\' && FLAGS.has(next)) {\n        this._escapedMask = this.replaceCharAt(this._escapedMask, j, '');\n        this.literals.set(j, next);\n        i++;\n      } else {\n        if (!FLAGS.has(current)) {\n          this.literals.set(j, current);\n        }\n      }\n    }\n  }\n  isPromptChar(char) {\n    return char === this.prompt;\n  }\n  replaceCharAt(string, pos, char) {\n    return `${string.substring(0, pos)}${char}${string.substring(pos + 1)}`;\n  }\n  validate(char, maskedChar) {\n    const regex = REGEX.get(maskedChar);\n    return regex ? regex.test(char) : false;\n  }\n  getNonLiteralPositions(mask = '') {\n    const positions = this.literalPositions;\n    return Array.from(mask).map((_, pos) => !positions.includes(pos) ? pos : -1).filter(pos => pos > -1);\n  }\n  getRequiredNonLiteralPositions(mask) {\n    const positions = this.literalPositions;\n    return Array.from(mask).map((char, pos) => REQUIRED.has(char) && !positions.includes(pos) ? pos : -1).filter(pos => pos > -1);\n  }\n  getPreviousNonLiteralPosition(start) {\n    const positions = this.literalPositions;\n    for (let i = start; i > 0; i--) {\n      if (!positions.includes(i)) return i;\n    }\n    return start;\n  }\n  getNextNonLiteralPosition(start) {\n    const positions = this.literalPositions;\n    for (let i = start; i < this._escapedMask.length; i++) {\n      if (!positions.includes(i)) return i;\n    }\n    return start;\n  }\n  replace(masked = '', value, start, end) {\n    const chars = Array.from(replaceIMENumbers(value));\n    const positions = this.literalPositions;\n    end = Math.min(end, masked.length);\n    let cursor = start;\n    for (let i = start; i < end || chars.length && i < masked.length; i++) {\n      if (positions.includes(i)) {\n        if (chars[0] === masked[i]) {\n          cursor = i + 1;\n          chars.shift();\n        }\n        continue;\n      }\n      if (chars[0] && !this.validate(chars[0], this._escapedMask[i]) && !this.isPromptChar(chars[0])) {\n        break;\n      }\n      let char = this.prompt;\n      if (chars.length) {\n        cursor = i + 1;\n        char = chars.shift();\n      }\n      masked = this.replaceCharAt(masked, i, char);\n    }\n    return {\n      value: masked,\n      end: cursor\n    };\n  }\n  parse(masked = '') {\n    return Array.from(masked).reduce((prev, char, pos) => {\n      return `${prev}${!this.literalPositions.includes(pos) && !this.isPromptChar(char) ? char : ''}`;\n    }, '');\n  }\n  isValidString(input = '') {\n    const required = this.getRequiredNonLiteralPositions(this._escapedMask);\n    if (required.length > this.parse(input).length) {\n      return false;\n    }\n    return required.every(pos => {\n      const char = input.charAt(pos);\n      return char !== undefined && this.validate(char, this._escapedMask.charAt(pos)) && !this.isPromptChar(char);\n    });\n  }\n  apply(input = '') {\n    const nonLiteralPositions = this.getNonLiteralPositions(this._escapedMask);\n    let output = new Array(this._escapedMask.length).fill(this.prompt).join('');\n    this.literals.forEach((char, pos) => {\n      output = this.replaceCharAt(output, pos, char);\n    });\n    if (!input) {\n      return output;\n    }\n    const values = nonLiteralPositions.map((pos, index) => {\n      const char = input.charAt(index);\n      return !this.validate(char, this._escapedMask.charAt(pos)) && !this.isPromptChar(char) ? this.prompt : char;\n    });\n    if (values.length > nonLiteralPositions.length) {\n      values.splice(nonLiteralPositions.length);\n    }\n    let pos = 0;\n    for (const each of values) {\n      output = this.replaceCharAt(output, nonLiteralPositions[pos++], each);\n    }\n    return output;\n  }\n}","map":{"version":3,"names":["FLAGS","Set","REGEX","Map","REQUIRED","replaceIMENumbers","string","replace","num","MaskParser","constructor","options","format","promptCharacter","literals","literalPositions","getMaskLiterals","Array","from","keys","escapedMask","_escapedMask","mask","value","prompt","substring","clear","i","j","length","current","next","charAt","has","replaceCharAt","set","isPromptChar","char","pos","validate","maskedChar","regex","get","test","getNonLiteralPositions","positions","map","_","includes","filter","getRequiredNonLiteralPositions","getPreviousNonLiteralPosition","start","getNextNonLiteralPosition","masked","end","chars","Math","min","cursor","shift","parse","reduce","prev","isValidString","input","required","every","undefined","apply","nonLiteralPositions","output","fill","join","forEach","values","index","splice","each"],"sources":["../../../src/components/mask-input/mask-parser.ts"],"sourcesContent":["interface MaskOptions {\n  format: string;\n  promptCharacter: string;\n}\n\nconst FLAGS = new Set('aACL09#&?');\nconst REGEX = new Map([\n  ['C', /(?!^$)/u], // Non-empty\n  ['&', /[^\\p{Separator}]/u], // Whitespace\n  ['a', /[\\p{Letter}\\d\\p{Separator}]/u], // Alphanumeric & whitespace\n  ['A', /[\\p{Letter}\\d]/u], // Alphanumeric\n  ['?', /[\\p{Letter}\\p{Separator}]/u], // Alpha & whitespace\n  ['L', /\\p{Letter}/u], // Alpha\n  ['0', /\\d/], // Numeric\n  ['9', /[\\d\\p{Separator}]/u], // Numeric & whitespace\n  ['#', /[\\d\\-+]/], // Numeric and sign\n]);\nconst REQUIRED = new Set('0#LA&');\n\nconst replaceIMENumbers = (string: string) => {\n  return string.replace(\n    /[０１２３４５６７８９]/g,\n    (num) =>\n      ({\n        '１': '1',\n        '２': '2',\n        '３': '3',\n        '４': '4',\n        '５': '5',\n        '６': '6',\n        '７': '7',\n        '８': '8',\n        '９': '9',\n        '０': '0',\n      }[num] as string)\n  );\n};\n\nexport class MaskParser {\n  protected options!: MaskOptions;\n\n  constructor(\n    options: MaskOptions = { format: 'CCCCCCCCCC', promptCharacter: '_' }\n  ) {\n    this.options = options;\n  }\n\n  protected literals = new Map<number, string>();\n  protected _escapedMask!: string;\n\n  public get literalPositions() {\n    this.getMaskLiterals();\n    return Array.from(this.literals.keys());\n  }\n\n  public get escapedMask() {\n    this.getMaskLiterals();\n    return this._escapedMask;\n  }\n\n  public get mask() {\n    return this.options.format;\n  }\n\n  public set mask(value: string) {\n    this.options.format = value || this.options.format;\n    this.getMaskLiterals();\n  }\n\n  public get prompt() {\n    return this.options.promptCharacter;\n  }\n\n  public set prompt(value: string) {\n    this.options.promptCharacter = value\n      ? value.substring(0, 1)\n      : this.options.promptCharacter;\n  }\n\n  protected getMaskLiterals() {\n    this.literals.clear();\n    this._escapedMask = this.mask;\n\n    for (let i = 0, j = 0; i < this.mask.length; i++, j++) {\n      const [current, next] = [this.mask.charAt(i), this.mask.charAt(i + 1)];\n\n      if (current === '\\\\' && FLAGS.has(next)) {\n        this._escapedMask = this.replaceCharAt(this._escapedMask, j, '');\n        this.literals.set(j, next);\n        i++;\n      } else {\n        if (!FLAGS.has(current)) {\n          this.literals.set(j, current);\n        }\n      }\n    }\n  }\n\n  protected isPromptChar(char: string) {\n    return char === this.prompt;\n  }\n\n  protected replaceCharAt(string: string, pos: number, char: string) {\n    return `${string.substring(0, pos)}${char}${string.substring(pos + 1)}`;\n  }\n\n  protected validate(char: string, maskedChar: string) {\n    const regex = REGEX.get(maskedChar);\n    return regex ? regex.test(char) : false;\n  }\n\n  protected getNonLiteralPositions(mask = '') {\n    const positions = this.literalPositions;\n    return Array.from(mask)\n      .map((_, pos) => (!positions.includes(pos) ? pos : -1))\n      .filter((pos) => pos > -1);\n  }\n\n  protected getRequiredNonLiteralPositions(mask: string) {\n    const positions = this.literalPositions;\n    return Array.from(mask)\n      .map((char, pos) =>\n        REQUIRED.has(char) && !positions.includes(pos) ? pos : -1\n      )\n      .filter((pos) => pos > -1);\n  }\n\n  public getPreviousNonLiteralPosition(start: number) {\n    const positions = this.literalPositions;\n    for (let i = start; i > 0; i--) {\n      if (!positions.includes(i)) return i;\n    }\n    return start;\n  }\n\n  public getNextNonLiteralPosition(start: number) {\n    const positions = this.literalPositions;\n    for (let i = start; i < this._escapedMask.length; i++) {\n      if (!positions.includes(i)) return i;\n    }\n    return start;\n  }\n\n  public replace(masked = '', value: string, start: number, end: number) {\n    const chars = Array.from(replaceIMENumbers(value));\n    const positions = this.literalPositions;\n    end = Math.min(end, masked.length);\n    let cursor = start;\n\n    for (let i = start; i < end || (chars.length && i < masked.length); i++) {\n      if (positions.includes(i)) {\n        if (chars[0] === masked[i]) {\n          cursor = i + 1;\n          chars.shift();\n        }\n        continue;\n      }\n\n      if (\n        chars[0] &&\n        !this.validate(chars[0], this._escapedMask[i]) &&\n        !this.isPromptChar(chars[0])\n      ) {\n        break;\n      }\n\n      let char = this.prompt;\n      if (chars.length) {\n        cursor = i + 1;\n        char = chars.shift() as string;\n      }\n      masked = this.replaceCharAt(masked, i, char);\n    }\n\n    return { value: masked, end: cursor };\n  }\n\n  public parse(masked = '') {\n    return Array.from(masked).reduce((prev, char, pos) => {\n      return `${prev}${\n        !this.literalPositions.includes(pos) && !this.isPromptChar(char)\n          ? char\n          : ''\n      }`;\n    }, '');\n  }\n\n  public isValidString(input = '') {\n    const required = this.getRequiredNonLiteralPositions(this._escapedMask);\n\n    if (required.length > this.parse(input).length) {\n      return false;\n    }\n    return required.every((pos) => {\n      const char = input.charAt(pos);\n      return (\n        char !== undefined &&\n        this.validate(char, this._escapedMask.charAt(pos)) &&\n        !this.isPromptChar(char)\n      );\n    });\n  }\n\n  public apply(input = '') {\n    const nonLiteralPositions = this.getNonLiteralPositions(this._escapedMask);\n    let output = new Array(this._escapedMask.length).fill(this.prompt).join('');\n\n    this.literals.forEach((char, pos) => {\n      output = this.replaceCharAt(output, pos, char);\n    });\n\n    if (!input) {\n      return output;\n    }\n\n    const values = nonLiteralPositions.map((pos, index) => {\n      const char = input.charAt(index);\n      return !this.validate(char, this._escapedMask.charAt(pos)) &&\n        !this.isPromptChar(char)\n        ? this.prompt\n        : char;\n    });\n\n    if (values.length > nonLiteralPositions.length) {\n      values.splice(nonLiteralPositions.length);\n    }\n\n    let pos = 0;\n    for (const each of values) {\n      output = this.replaceCharAt(output, nonLiteralPositions[pos++], each);\n    }\n\n    return output;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}