{"ast":null,"code":"export function watch(propName, options) {\n  return (protoOrDescriptor, name) => {\n    const {\n      willUpdate\n    } = protoOrDescriptor;\n    options = Object.assign({\n      waitUntilFirstUpdate: false\n    }, options);\n    protoOrDescriptor.willUpdate = function (changedProps) {\n      willUpdate.call(this, changedProps);\n      if (changedProps.has(propName)) {\n        const oldValue = changedProps.get(propName);\n        const newValue = this[propName];\n        if (oldValue !== newValue) {\n          if (!(options === null || options === void 0 ? void 0 : options.waitUntilFirstUpdate) || this.hasUpdated) {\n            this[name].call(this, oldValue, newValue);\n          }\n        }\n      }\n    };\n  };\n}","map":{"version":3,"names":["watch","propName","options","protoOrDescriptor","name","willUpdate","Object","assign","waitUntilFirstUpdate","changedProps","call","has","oldValue","get","newValue","hasUpdated"],"sources":["../../../../src/components/common/decorators/watch.ts"],"sourcesContent":["// @watch decorator\n//\n// Runs when an observed property changes, e.g. @property or @state, but before the component updates.\n//\n// To wait for an update to complete after a change occurs, use `await this.updateComplete` in the handler. To start\n// watching after the initial update/render, use `{ waitUntilFirstUpdate: true }` or `this.hasUpdated` in the handler.\n//\n// Usage:\n//\n//  @watch('propName')\n//  handlePropChange(oldValue, newValue) {\n//    ...\n//  }\n//\ninterface WatchOptions {\n  waitUntilFirstUpdate?: boolean;\n}\n\nexport function watch(propName: string, options?: WatchOptions) {\n  return (protoOrDescriptor: any, name: string): any => {\n    const { willUpdate } = protoOrDescriptor;\n\n    options = Object.assign(\n      { waitUntilFirstUpdate: false },\n      options\n    ) as WatchOptions;\n\n    protoOrDescriptor.willUpdate = function (changedProps: Map<string, any>) {\n      willUpdate.call(this, changedProps);\n\n      if (changedProps.has(propName)) {\n        const oldValue = changedProps.get(propName);\n        const newValue = this[propName];\n\n        if (oldValue !== newValue) {\n          if (!options?.waitUntilFirstUpdate || this.hasUpdated) {\n            this[name].call(this, oldValue, newValue);\n          }\n        }\n      }\n    };\n  };\n}\n"],"mappings":"AAkBA,OAAM,SAAUA,KAAKA,CAACC,QAAgB,EAAEC,OAAsB;EAC5D,OAAO,CAACC,iBAAsB,EAAEC,IAAY,KAAS;IACnD,MAAM;MAAEC;IAAU,CAAE,GAAGF,iBAAiB;IAExCD,OAAO,GAAGI,MAAM,CAACC,MAAM,CACrB;MAAEC,oBAAoB,EAAE;IAAK,CAAE,EAC/BN,OAAO,CACQ;IAEjBC,iBAAiB,CAACE,UAAU,GAAG,UAAUI,YAA8B;MACrEJ,UAAU,CAACK,IAAI,CAAC,IAAI,EAAED,YAAY,CAAC;MAEnC,IAAIA,YAAY,CAACE,GAAG,CAACV,QAAQ,CAAC,EAAE;QAC9B,MAAMW,QAAQ,GAAGH,YAAY,CAACI,GAAG,CAACZ,QAAQ,CAAC;QAC3C,MAAMa,QAAQ,GAAG,IAAI,CAACb,QAAQ,CAAC;QAE/B,IAAIW,QAAQ,KAAKE,QAAQ,EAAE;UACzB,IAAI,EAACZ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEM,oBAAoB,KAAI,IAAI,CAACO,UAAU,EAAE;YACrD,IAAI,CAACX,IAAI,CAAC,CAACM,IAAI,CAAC,IAAI,EAAEE,QAAQ,EAAEE,QAAQ,CAAC;;;;IAIjD,CAAC;EACH,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}