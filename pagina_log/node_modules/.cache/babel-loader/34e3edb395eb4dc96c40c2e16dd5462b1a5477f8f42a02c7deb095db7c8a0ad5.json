{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nmodule.exports = (input, options = {}, fn) => {\n  if (typeof input !== 'string') throw new TypeError('expected a string');\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  }\n  let separator = options.separator || '.';\n  let ast = {\n    type: 'root',\n    nodes: [],\n    stash: ['']\n  };\n  let stack = [ast];\n  let state = {\n    input,\n    separator,\n    stack\n  };\n  let string = input;\n  let value, node;\n  let i = -1;\n  state.bos = () => i === 0;\n  state.eos = () => i === string.length;\n  state.prev = () => string[i - 1];\n  state.next = () => string[i + 1];\n  let quotes = options.quotes || [];\n  let openers = options.brackets || {};\n  if (options.brackets === true) {\n    openers = {\n      '[': ']',\n      '(': ')',\n      '{': '}',\n      '<': '>'\n    };\n  }\n  if (options.quotes === true) {\n    quotes = ['\"', '\\'', '`'];\n  }\n  let closers = invert(openers);\n  let keep = options.keep || (value => value !== '\\\\');\n  const block = () => state.block = stack[stack.length - 1];\n  const peek = () => string[i + 1];\n  const next = () => string[++i];\n  const append = value => {\n    state.value = value;\n    if (value && keep(value, state) !== false) {\n      state.block.stash[state.block.stash.length - 1] += value;\n    }\n  };\n  const closeIndex = (value, startIdx) => {\n    let idx = string.indexOf(value, startIdx);\n    if (idx > -1 && string[idx - 1] === '\\\\') {\n      idx = closeIndex(value, idx + 1);\n    }\n    return idx;\n  };\n  for (; i < string.length - 1;) {\n    state.value = value = next();\n    state.index = i;\n    block();\n\n    // handle escaped characters\n    if (value === '\\\\') {\n      if (peek() === '\\\\') {\n        append(value + next());\n      } else {\n        // if the next char is not '\\\\', allow the \"append\" function\n        // to determine if the backslashes should be added\n        append(value);\n        append(next());\n      }\n      continue;\n    }\n\n    // handle quoted strings\n    if (quotes.includes(value)) {\n      let pos = i + 1;\n      let idx = closeIndex(value, pos);\n      if (idx > -1) {\n        append(value); // append opening quote\n        append(string.slice(pos, idx)); // append quoted string\n        append(string[idx]); // append closing quote\n        i = idx;\n        continue;\n      }\n      append(value);\n      continue;\n    }\n\n    // handle opening brackets, if not disabled\n    if (options.brackets !== false && openers[value]) {\n      node = {\n        type: 'bracket',\n        nodes: []\n      };\n      node.stash = keep(value) !== false ? [value] : [''];\n      node.parent = state.block;\n      state.block.nodes.push(node);\n      stack.push(node);\n      continue;\n    }\n\n    // handle closing brackets, if not disabled\n    if (options.brackets !== false && closers[value]) {\n      if (stack.length === 1) {\n        append(value);\n        continue;\n      }\n      append(value);\n      node = stack.pop();\n      block();\n      append(node.stash.join(''));\n      continue;\n    }\n\n    // push separator onto stash\n    if (value === separator && state.block.type === 'root') {\n      if (typeof fn === 'function' && fn(state) === false) {\n        append(value);\n        continue;\n      }\n      state.block.stash.push('');\n      continue;\n    }\n\n    // append value onto the last string on the stash\n    append(value);\n  }\n  node = stack.pop();\n  while (node !== ast) {\n    if (options.strict === true) {\n      let column = i - node.stash.length + 1;\n      throw new SyntaxError(`Unmatched: \"${node.stash[0]}\", at column ${column}`);\n    }\n    value = node.parent.stash.pop() + node.stash.join('.');\n    node.parent.stash = node.parent.stash.concat(value.split('.'));\n    node = stack.pop();\n  }\n  return node.stash;\n};\nfunction invert(obj) {\n  let inverted = {};\n  for (const key of Object.keys(obj)) inverted[obj[key]] = key;\n  return inverted;\n}","map":{"version":3,"names":["require","module","exports","input","options","fn","TypeError","separator","ast","type","nodes","stash","stack","state","string","value","node","i","bos","eos","length","prev","next","quotes","openers","brackets","closers","invert","keep","block","peek","append","closeIndex","startIdx","idx","indexOf","index","includes","pos","slice","parent","push","pop","join","strict","column","SyntaxError","concat","split","obj","inverted","key","Object","keys"],"sources":["C:/Users/mthss/Documentos/Projeto_estagio/pagina_log/node_modules/split-string/index.js"],"sourcesContent":["'use strict';\n\nmodule.exports = (input, options = {}, fn) => {\n  if (typeof input !== 'string') throw new TypeError('expected a string');\n\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  }\n\n  let separator = options.separator || '.';\n  let ast = { type: 'root', nodes: [], stash: [''] };\n  let stack = [ast];\n  let state = { input, separator, stack };\n  let string = input;\n  let value, node;\n  let i = -1;\n\n  state.bos = () => i === 0;\n  state.eos = () => i === string.length;\n  state.prev = () => string[i - 1];\n  state.next = () => string[i + 1];\n\n  let quotes = options.quotes || [];\n  let openers = options.brackets || {};\n\n  if (options.brackets === true) {\n    openers = { '[': ']', '(': ')', '{': '}', '<': '>' };\n  }\n  if (options.quotes === true) {\n    quotes = ['\"', '\\'', '`'];\n  }\n\n  let closers = invert(openers);\n  let keep = options.keep || (value => value !== '\\\\');\n\n  const block = () => (state.block = stack[stack.length - 1]);\n  const peek = () => string[i + 1];\n  const next = () => string[++i];\n  const append = value => {\n    state.value = value;\n    if (value && keep(value, state) !== false) {\n      state.block.stash[state.block.stash.length - 1] += value;\n    }\n  };\n\n  const closeIndex = (value, startIdx) => {\n    let idx = string.indexOf(value, startIdx);\n    if (idx > -1 && string[idx - 1] === '\\\\') {\n      idx = closeIndex(value, idx + 1);\n    }\n    return idx;\n  };\n\n  for (; i < string.length - 1;) {\n    state.value = value = next();\n    state.index = i;\n    block();\n\n    // handle escaped characters\n    if (value === '\\\\') {\n      if (peek() === '\\\\') {\n        append(value + next());\n      } else {\n        // if the next char is not '\\\\', allow the \"append\" function\n        // to determine if the backslashes should be added\n        append(value);\n        append(next());\n      }\n      continue;\n    }\n\n    // handle quoted strings\n    if (quotes.includes(value)) {\n      let pos = i + 1;\n      let idx = closeIndex(value, pos);\n\n      if (idx > -1) {\n        append(value); // append opening quote\n        append(string.slice(pos, idx)); // append quoted string\n        append(string[idx]); // append closing quote\n        i = idx;\n        continue;\n      }\n\n      append(value);\n      continue;\n    }\n\n    // handle opening brackets, if not disabled\n    if (options.brackets !== false && openers[value]) {\n      node = { type: 'bracket', nodes: [] };\n      node.stash = keep(value) !== false ? [value] : [''];\n      node.parent = state.block;\n      state.block.nodes.push(node);\n      stack.push(node);\n      continue;\n    }\n\n    // handle closing brackets, if not disabled\n    if (options.brackets !== false && closers[value]) {\n      if (stack.length === 1) {\n        append(value);\n        continue;\n      }\n\n      append(value);\n      node = stack.pop();\n      block();\n      append(node.stash.join(''));\n      continue;\n    }\n\n    // push separator onto stash\n    if (value === separator && state.block.type === 'root') {\n      if (typeof fn === 'function' && fn(state) === false) {\n        append(value);\n        continue;\n      }\n      state.block.stash.push('');\n      continue;\n    }\n\n    // append value onto the last string on the stash\n    append(value);\n  }\n\n  node = stack.pop();\n\n  while (node !== ast) {\n    if (options.strict === true) {\n      let column = i - node.stash.length + 1;\n      throw new SyntaxError(`Unmatched: \"${node.stash[0]}\", at column ${column}`);\n    }\n\n    value = (node.parent.stash.pop() + node.stash.join('.'));\n    node.parent.stash = node.parent.stash.concat(value.split('.'));\n    node = stack.pop();\n  }\n\n  return node.stash;\n};\n\nfunction invert(obj) {\n  let inverted = {};\n  for (const key of Object.keys(obj)) inverted[obj[key]] = key;\n  return inverted;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}