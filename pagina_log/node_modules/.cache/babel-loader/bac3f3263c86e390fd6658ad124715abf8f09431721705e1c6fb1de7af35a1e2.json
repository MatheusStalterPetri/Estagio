{"ast":null,"code":"import \"core-js/modules/web.dom-exception.stack.js\";\nimport \"core-js/modules/es.regexp.flags.js\";\nimport \"core-js/modules/es.array.push.js\";\n/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nfunction assertType(condition, message, ...args) {\n  if (!condition) {\n    throw new TypeError(format(message, args));\n  }\n}\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nfunction format(message, args) {\n  let i = 0;\n  return message.replace(/%[os]/gu, () => anyToString(args[i++]));\n}\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nfunction anyToString(x) {\n  if (typeof x !== \"object\" || x === null) {\n    return String(x);\n  }\n  return Object.prototype.toString.call(x);\n}\nlet currentErrorHandler;\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nfunction setErrorHandler(value) {\n  assertType(typeof value === \"function\" || value === undefined, \"The error handler must be a function or undefined, but got %o.\", value);\n  currentErrorHandler = value;\n}\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nfunction reportError(maybeError) {\n  try {\n    const error = maybeError instanceof Error ? maybeError : new Error(anyToString(maybeError));\n    // Call the user-defined error handler if exists.\n    if (currentErrorHandler) {\n      currentErrorHandler(error);\n      return;\n    }\n    // Dispatch an `error` event if this is on a browser.\n    if (typeof dispatchEvent === \"function\" && typeof ErrorEvent === \"function\") {\n      dispatchEvent(new ErrorEvent(\"error\", {\n        error,\n        message: error.message\n      }));\n    }\n    // Emit an `uncaughtException` event if this is on Node.js.\n    //istanbul ignore else\n    else if (typeof process !== \"undefined\" && typeof process.emit === \"function\") {\n      process.emit(\"uncaughtException\", error);\n      return;\n    }\n    // Otherwise, print the error.\n    console.error(error);\n  } catch (_a) {\n    // ignore.\n  }\n}\n\n/**\n * The global object.\n */\n//istanbul ignore next\nconst Global = typeof window !== \"undefined\" ? window : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof globalThis !== \"undefined\" ? globalThis : undefined;\nlet currentWarnHandler;\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nfunction setWarningHandler(value) {\n  assertType(typeof value === \"function\" || value === undefined, \"The warning handler must be a function or undefined, but got %o.\", value);\n  currentWarnHandler = value;\n}\n/**\n * The warning information.\n */\nclass Warning {\n  constructor(code, message) {\n    this.code = code;\n    this.message = message;\n  }\n  /**\n   * Report this warning.\n   * @param args The arguments of the warning.\n   */\n  warn(...args) {\n    var _a;\n    try {\n      // Call the user-defined warning handler if exists.\n      if (currentWarnHandler) {\n        currentWarnHandler({\n          ...this,\n          args\n        });\n        return;\n      }\n      // Otherwise, print the warning.\n      const stack = ((_a = new Error().stack) !== null && _a !== void 0 ? _a : \"\").replace(/^(?:.+?\\n){2}/gu, \"\\n\");\n      console.warn(this.message, ...args, stack);\n    } catch (_b) {\n      // Ignore.\n    }\n  }\n}\nconst InitEventWasCalledWhileDispatching = new Warning(\"W01\", \"Unable to initialize event under dispatching.\");\nconst FalsyWasAssignedToCancelBubble = new Warning(\"W02\", \"Assigning any falsy value to 'cancelBubble' property has no effect.\");\nconst TruthyWasAssignedToReturnValue = new Warning(\"W03\", \"Assigning any truthy value to 'returnValue' property has no effect.\");\nconst NonCancelableEventWasCanceled = new Warning(\"W04\", \"Unable to preventDefault on non-cancelable events.\");\nconst CanceledInPassiveListener = new Warning(\"W05\", \"Unable to preventDefault inside passive event listener invocation.\");\nconst EventListenerWasDuplicated = new Warning(\"W06\", \"An event listener wasn't added because it has been added already: %o, %o\");\nconst OptionWasIgnored = new Warning(\"W07\", \"The %o option value was abandoned because the event listener wasn't added as duplicated.\");\nconst InvalidEventListener = new Warning(\"W08\", \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\");\nconst InvalidAttributeHandler = new Warning(\"W09\", \"Event attribute handler must be a function: %o\");\n\n/*eslint-disable class-methods-use-this */\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nclass Event {\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-none\n   */\n  static get NONE() {\n    return NONE;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n   */\n  static get CAPTURING_PHASE() {\n    return CAPTURING_PHASE;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-at_target\n   */\n  static get AT_TARGET() {\n    return AT_TARGET;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n   */\n  static get BUBBLING_PHASE() {\n    return BUBBLING_PHASE;\n  }\n  /**\n   * Initialize this event instance.\n   * @param type The type of this event.\n   * @param eventInitDict Options to initialize.\n   * @see https://dom.spec.whatwg.org/#dom-event-event\n   */\n  constructor(type, eventInitDict) {\n    Object.defineProperty(this, \"isTrusted\", {\n      value: false,\n      enumerable: true\n    });\n    const opts = eventInitDict !== null && eventInitDict !== void 0 ? eventInitDict : {};\n    internalDataMap.set(this, {\n      type: String(type),\n      bubbles: Boolean(opts.bubbles),\n      cancelable: Boolean(opts.cancelable),\n      composed: Boolean(opts.composed),\n      target: null,\n      currentTarget: null,\n      stopPropagationFlag: false,\n      stopImmediatePropagationFlag: false,\n      canceledFlag: false,\n      inPassiveListenerFlag: false,\n      dispatchFlag: false,\n      timeStamp: Date.now()\n    });\n  }\n  /**\n   * The type of this event.\n   * @see https://dom.spec.whatwg.org/#dom-event-type\n   */\n  get type() {\n    return $(this).type;\n  }\n  /**\n   * The event target of the current dispatching.\n   * @see https://dom.spec.whatwg.org/#dom-event-target\n   */\n  get target() {\n    return $(this).target;\n  }\n  /**\n   * The event target of the current dispatching.\n   * @deprecated Use the `target` property instead.\n   * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n   */\n  get srcElement() {\n    return $(this).target;\n  }\n  /**\n   * The event target of the current dispatching.\n   * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n   */\n  get currentTarget() {\n    return $(this).currentTarget;\n  }\n  /**\n   * The event target of the current dispatching.\n   * This doesn't support node tree.\n   * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n   */\n  composedPath() {\n    const currentTarget = $(this).currentTarget;\n    if (currentTarget) {\n      return [currentTarget];\n    }\n    return [];\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-none\n   */\n  get NONE() {\n    return NONE;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n   */\n  get CAPTURING_PHASE() {\n    return CAPTURING_PHASE;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-at_target\n   */\n  get AT_TARGET() {\n    return AT_TARGET;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n   */\n  get BUBBLING_PHASE() {\n    return BUBBLING_PHASE;\n  }\n  /**\n   * The current event phase.\n   * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n   */\n  get eventPhase() {\n    return $(this).dispatchFlag ? 2 : 0;\n  }\n  /**\n   * Stop event bubbling.\n   * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n   * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n   */\n  stopPropagation() {\n    $(this).stopPropagationFlag = true;\n  }\n  /**\n   * `true` if event bubbling was stopped.\n   * @deprecated\n   * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n   */\n  get cancelBubble() {\n    return $(this).stopPropagationFlag;\n  }\n  /**\n   * Stop event bubbling if `true` is set.\n   * @deprecated Use the `stopPropagation()` method instead.\n   * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n   */\n  set cancelBubble(value) {\n    if (value) {\n      $(this).stopPropagationFlag = true;\n    } else {\n      FalsyWasAssignedToCancelBubble.warn();\n    }\n  }\n  /**\n   * Stop event bubbling and subsequent event listener callings.\n   * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n   */\n  stopImmediatePropagation() {\n    const data = $(this);\n    data.stopPropagationFlag = data.stopImmediatePropagationFlag = true;\n  }\n  /**\n   * `true` if this event will bubble.\n   * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n   */\n  get bubbles() {\n    return $(this).bubbles;\n  }\n  /**\n   * `true` if this event can be canceled by the `preventDefault()` method.\n   * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n   */\n  get cancelable() {\n    return $(this).cancelable;\n  }\n  /**\n   * `true` if the default behavior will act.\n   * @deprecated Use the `defaultPrevented` proeprty instead.\n   * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n   */\n  get returnValue() {\n    return !$(this).canceledFlag;\n  }\n  /**\n   * Cancel the default behavior if `false` is set.\n   * @deprecated Use the `preventDefault()` method instead.\n   * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n   */\n  set returnValue(value) {\n    if (!value) {\n      setCancelFlag($(this));\n    } else {\n      TruthyWasAssignedToReturnValue.warn();\n    }\n  }\n  /**\n   * Cancel the default behavior.\n   * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n   */\n  preventDefault() {\n    setCancelFlag($(this));\n  }\n  /**\n   * `true` if the default behavior was canceled.\n   * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n   */\n  get defaultPrevented() {\n    return $(this).canceledFlag;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-composed\n   */\n  get composed() {\n    return $(this).composed;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n   */\n  //istanbul ignore next\n  get isTrusted() {\n    return false;\n  }\n  /**\n   * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n   */\n  get timeStamp() {\n    return $(this).timeStamp;\n  }\n  /**\n   * @deprecated Don't use this method. The constructor did initialization.\n   */\n  initEvent(type, bubbles = false, cancelable = false) {\n    const data = $(this);\n    if (data.dispatchFlag) {\n      InitEventWasCalledWhileDispatching.warn();\n      return;\n    }\n    internalDataMap.set(this, {\n      ...data,\n      type: String(type),\n      bubbles: Boolean(bubbles),\n      cancelable: Boolean(cancelable),\n      target: null,\n      currentTarget: null,\n      stopPropagationFlag: false,\n      stopImmediatePropagationFlag: false,\n      canceledFlag: false\n    });\n  }\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nconst NONE = 0;\nconst CAPTURING_PHASE = 1;\nconst AT_TARGET = 2;\nconst BUBBLING_PHASE = 3;\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap();\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event, name = \"this\") {\n  const retv = internalDataMap.get(event);\n  assertType(retv != null, \"'%s' must be an object that Event constructor created, but got another one: %o\", name, event);\n  return retv;\n}\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data) {\n  if (data.inPassiveListenerFlag) {\n    CanceledInPassiveListener.warn();\n    return;\n  }\n  if (!data.cancelable) {\n    NonCancelableEventWasCanceled.warn();\n    return;\n  }\n  data.canceledFlag = true;\n}\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", {\n  enumerable: true\n});\nObject.defineProperty(Event, \"CAPTURING_PHASE\", {\n  enumerable: true\n});\nObject.defineProperty(Event, \"AT_TARGET\", {\n  enumerable: true\n});\nObject.defineProperty(Event, \"BUBBLING_PHASE\", {\n  enumerable: true\n});\nconst keys = Object.getOwnPropertyNames(Event.prototype);\nfor (let i = 0; i < keys.length; ++i) {\n  if (keys[i] === \"constructor\") {\n    continue;\n  }\n  Object.defineProperty(Event.prototype, keys[i], {\n    enumerable: true\n  });\n}\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n  Object.setPrototypeOf(Event.prototype, Global.Event.prototype);\n}\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nfunction createInvalidStateError(message) {\n  if (Global.DOMException) {\n    return new Global.DOMException(message, \"InvalidStateError\");\n  }\n  if (DOMException == null) {\n    DOMException = class DOMException extends Error {\n      constructor(msg) {\n        super(msg);\n        if (Error.captureStackTrace) {\n          Error.captureStackTrace(this, DOMException);\n        }\n      }\n      // eslint-disable-next-line class-methods-use-this\n      get code() {\n        return 11;\n      }\n      // eslint-disable-next-line class-methods-use-this\n      get name() {\n        return \"InvalidStateError\";\n      }\n    };\n    Object.defineProperties(DOMException.prototype, {\n      code: {\n        enumerable: true\n      },\n      name: {\n        enumerable: true\n      }\n    });\n    defineErrorCodeProperties(DOMException);\n    defineErrorCodeProperties(DOMException.prototype);\n  }\n  return new DOMException(message);\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\nlet DOMException;\nconst ErrorCodeMap = {\n  INDEX_SIZE_ERR: 1,\n  DOMSTRING_SIZE_ERR: 2,\n  HIERARCHY_REQUEST_ERR: 3,\n  WRONG_DOCUMENT_ERR: 4,\n  INVALID_CHARACTER_ERR: 5,\n  NO_DATA_ALLOWED_ERR: 6,\n  NO_MODIFICATION_ALLOWED_ERR: 7,\n  NOT_FOUND_ERR: 8,\n  NOT_SUPPORTED_ERR: 9,\n  INUSE_ATTRIBUTE_ERR: 10,\n  INVALID_STATE_ERR: 11,\n  SYNTAX_ERR: 12,\n  INVALID_MODIFICATION_ERR: 13,\n  NAMESPACE_ERR: 14,\n  INVALID_ACCESS_ERR: 15,\n  VALIDATION_ERR: 16,\n  TYPE_MISMATCH_ERR: 17,\n  SECURITY_ERR: 18,\n  NETWORK_ERR: 19,\n  ABORT_ERR: 20,\n  URL_MISMATCH_ERR: 21,\n  QUOTA_EXCEEDED_ERR: 22,\n  TIMEOUT_ERR: 23,\n  INVALID_NODE_TYPE_ERR: 24,\n  DATA_CLONE_ERR: 25\n};\nfunction defineErrorCodeProperties(obj) {\n  const keys = Object.keys(ErrorCodeMap);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    const value = ErrorCodeMap[key];\n    Object.defineProperty(obj, key, {\n      get() {\n        return value;\n      },\n      configurable: true,\n      enumerable: true\n    });\n  }\n}\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nclass EventWrapper extends Event {\n  /**\n   * Wrap a given event object to control states.\n   * @param event The event-like object to wrap.\n   */\n  static wrap(event) {\n    return new (getWrapperClassOf(event))(event);\n  }\n  constructor(event) {\n    super(event.type, {\n      bubbles: event.bubbles,\n      cancelable: event.cancelable,\n      composed: event.composed\n    });\n    if (event.cancelBubble) {\n      super.stopPropagation();\n    }\n    if (event.defaultPrevented) {\n      super.preventDefault();\n    }\n    internalDataMap$1.set(this, {\n      original: event\n    });\n    // Define accessors\n    const keys = Object.keys(event);\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (!(key in this)) {\n        Object.defineProperty(this, key, defineRedirectDescriptor(event, key));\n      }\n    }\n  }\n  stopPropagation() {\n    super.stopPropagation();\n    const {\n      original\n    } = $$1(this);\n    if (\"stopPropagation\" in original) {\n      original.stopPropagation();\n    }\n  }\n  get cancelBubble() {\n    return super.cancelBubble;\n  }\n  set cancelBubble(value) {\n    super.cancelBubble = value;\n    const {\n      original\n    } = $$1(this);\n    if (\"cancelBubble\" in original) {\n      original.cancelBubble = value;\n    }\n  }\n  stopImmediatePropagation() {\n    super.stopImmediatePropagation();\n    const {\n      original\n    } = $$1(this);\n    if (\"stopImmediatePropagation\" in original) {\n      original.stopImmediatePropagation();\n    }\n  }\n  get returnValue() {\n    return super.returnValue;\n  }\n  set returnValue(value) {\n    super.returnValue = value;\n    const {\n      original\n    } = $$1(this);\n    if (\"returnValue\" in original) {\n      original.returnValue = value;\n    }\n  }\n  preventDefault() {\n    super.preventDefault();\n    const {\n      original\n    } = $$1(this);\n    if (\"preventDefault\" in original) {\n      original.preventDefault();\n    }\n  }\n  get timeStamp() {\n    const {\n      original\n    } = $$1(this);\n    if (\"timeStamp\" in original) {\n      return original.timeStamp;\n    }\n    return super.timeStamp;\n  }\n}\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap$1 = new WeakMap();\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $$1(event) {\n  const retv = internalDataMap$1.get(event);\n  assertType(retv != null, \"'this' is expected an Event object, but got\", event);\n  return retv;\n}\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap();\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper);\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n  wrapperClassCache.set(Global.Event.prototype, EventWrapper);\n}\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf(originalEvent) {\n  const prototype = Object.getPrototypeOf(originalEvent);\n  if (prototype == null) {\n    return EventWrapper;\n  }\n  let wrapper = wrapperClassCache.get(prototype);\n  if (wrapper == null) {\n    wrapper = defineWrapper(getWrapperClassOf(prototype), prototype);\n    wrapperClassCache.set(prototype, wrapper);\n  }\n  return wrapper;\n}\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper, originalPrototype) {\n  class CustomEventWrapper extends BaseEventWrapper {}\n  const keys = Object.keys(originalPrototype);\n  for (let i = 0; i < keys.length; ++i) {\n    Object.defineProperty(CustomEventWrapper.prototype, keys[i], defineRedirectDescriptor(originalPrototype, keys[i]));\n  }\n  return CustomEventWrapper;\n}\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj, key) {\n  const d = Object.getOwnPropertyDescriptor(obj, key);\n  return {\n    get() {\n      const original = $$1(this).original;\n      const value = original[key];\n      if (typeof value === \"function\") {\n        return value.bind(original);\n      }\n      return value;\n    },\n    set(value) {\n      const original = $$1(this).original;\n      original[key] = value;\n    },\n    configurable: d.configurable,\n    enumerable: d.enumerable\n  };\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nfunction createListener(callback, capture, passive, once, signal, signalListener) {\n  return {\n    callback,\n    flags: (capture ? 1 /* Capture */ : 0) | (passive ? 2 /* Passive */ : 0) | (once ? 4 /* Once */ : 0),\n    signal,\n    signalListener\n  };\n}\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nfunction setRemoved(listener) {\n  listener.flags |= 8 /* Removed */;\n}\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nfunction isCapture(listener) {\n  return (listener.flags & 1 /* Capture */) === 1 /* Capture */;\n}\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nfunction isPassive(listener) {\n  return (listener.flags & 2 /* Passive */) === 2 /* Passive */;\n}\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nfunction isOnce(listener) {\n  return (listener.flags & 4 /* Once */) === 4 /* Once */;\n}\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nfunction isRemoved(listener) {\n  return (listener.flags & 8 /* Removed */) === 8 /* Removed */;\n}\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nfunction invokeCallback({\n  callback\n}, target, event) {\n  try {\n    if (typeof callback === \"function\") {\n      callback.call(target, event);\n    } else if (typeof callback.handleEvent === \"function\") {\n      callback.handleEvent(event);\n    }\n  } catch (thrownError) {\n    reportError(thrownError);\n  }\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nfunction findIndexOfListener({\n  listeners\n}, callback, capture) {\n  for (let i = 0; i < listeners.length; ++i) {\n    if (listeners[i].callback === callback && isCapture(listeners[i]) === capture) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nfunction addListener(list, callback, capture, passive, once, signal) {\n  let signalListener;\n  if (signal) {\n    signalListener = removeListener.bind(null, list, callback, capture);\n    signal.addEventListener(\"abort\", signalListener);\n  }\n  const listener = createListener(callback, capture, passive, once, signal, signalListener);\n  if (list.cow) {\n    list.cow = false;\n    list.listeners = [...list.listeners, listener];\n  } else {\n    list.listeners.push(listener);\n  }\n  return listener;\n}\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nfunction removeListener(list, callback, capture) {\n  const index = findIndexOfListener(list, callback, capture);\n  if (index !== -1) {\n    return removeListenerAt(list, index);\n  }\n  return false;\n}\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nfunction removeListenerAt(list, index, disableCow = false) {\n  const listener = list.listeners[index];\n  // Set the removed flag.\n  setRemoved(listener);\n  // Dispose the abort signal listener if exists.\n  if (listener.signal) {\n    listener.signal.removeEventListener(\"abort\", listener.signalListener);\n  }\n  // Remove it from the array.\n  if (list.cow && !disableCow) {\n    list.cow = false;\n    list.listeners = list.listeners.filter((_, i) => i !== index);\n    return false;\n  }\n  list.listeners.splice(index, 1);\n  return true;\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nfunction createListenerListMap() {\n  return Object.create(null);\n}\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nfunction ensureListenerList(listenerMap, type) {\n  var _a;\n  return (_a = listenerMap[type]) !== null && _a !== void 0 ? _a : listenerMap[type] = {\n    attrCallback: undefined,\n    attrListener: undefined,\n    cow: false,\n    listeners: []\n  };\n}\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nclass EventTarget {\n  /**\n   * Initialize this instance.\n   */\n  constructor() {\n    internalDataMap$2.set(this, createListenerListMap());\n  }\n  // Implementation\n  addEventListener(type0, callback0, options0) {\n    const listenerMap = $$2(this);\n    const {\n      callback,\n      capture,\n      once,\n      passive,\n      signal,\n      type\n    } = normalizeAddOptions(type0, callback0, options0);\n    if (callback == null || (signal === null || signal === void 0 ? void 0 : signal.aborted)) {\n      return;\n    }\n    const list = ensureListenerList(listenerMap, type);\n    // Find existing listener.\n    const i = findIndexOfListener(list, callback, capture);\n    if (i !== -1) {\n      warnDuplicate(list.listeners[i], passive, once, signal);\n      return;\n    }\n    // Add the new listener.\n    addListener(list, callback, capture, passive, once, signal);\n  }\n  // Implementation\n  removeEventListener(type0, callback0, options0) {\n    const listenerMap = $$2(this);\n    const {\n      callback,\n      capture,\n      type\n    } = normalizeOptions(type0, callback0, options0);\n    const list = listenerMap[type];\n    if (callback != null && list) {\n      removeListener(list, callback, capture);\n    }\n  }\n  // Implementation\n  dispatchEvent(e) {\n    const list = $$2(this)[String(e.type)];\n    if (list == null) {\n      return true;\n    }\n    const event = e instanceof Event ? e : EventWrapper.wrap(e);\n    const eventData = $(event, \"event\");\n    if (eventData.dispatchFlag) {\n      throw createInvalidStateError(\"This event has been in dispatching.\");\n    }\n    eventData.dispatchFlag = true;\n    eventData.target = eventData.currentTarget = this;\n    if (!eventData.stopPropagationFlag) {\n      const {\n        cow,\n        listeners\n      } = list;\n      // Set copy-on-write flag.\n      list.cow = true;\n      // Call listeners.\n      for (let i = 0; i < listeners.length; ++i) {\n        const listener = listeners[i];\n        // Skip if removed.\n        if (isRemoved(listener)) {\n          continue;\n        }\n        // Remove this listener if has the `once` flag.\n        if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n          // Because this listener was removed, the next index is the\n          // same as the current value.\n          i -= 1;\n        }\n        // Call this listener with the `passive` flag.\n        eventData.inPassiveListenerFlag = isPassive(listener);\n        invokeCallback(listener, this, event);\n        eventData.inPassiveListenerFlag = false;\n        // Stop if the `event.stopImmediatePropagation()` method was called.\n        if (eventData.stopImmediatePropagationFlag) {\n          break;\n        }\n      }\n      // Restore copy-on-write flag.\n      if (!cow) {\n        list.cow = false;\n      }\n    }\n    eventData.target = null;\n    eventData.currentTarget = null;\n    eventData.stopImmediatePropagationFlag = false;\n    eventData.stopPropagationFlag = false;\n    eventData.dispatchFlag = false;\n    return !eventData.canceledFlag;\n  }\n}\n/**\n * Internal data.\n */\nconst internalDataMap$2 = new WeakMap();\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $$2(target, name = \"this\") {\n  const retv = internalDataMap$2.get(target);\n  assertType(retv != null, \"'%s' must be an object that EventTarget constructor created, but got another one: %o\", name, target);\n  return retv;\n}\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(type, callback, options) {\n  var _a;\n  assertCallback(callback);\n  if (typeof options === \"object\" && options !== null) {\n    return {\n      type: String(type),\n      callback: callback !== null && callback !== void 0 ? callback : undefined,\n      capture: Boolean(options.capture),\n      passive: Boolean(options.passive),\n      once: Boolean(options.once),\n      signal: (_a = options.signal) !== null && _a !== void 0 ? _a : undefined\n    };\n  }\n  return {\n    type: String(type),\n    callback: callback !== null && callback !== void 0 ? callback : undefined,\n    capture: Boolean(options),\n    passive: false,\n    once: false,\n    signal: undefined\n  };\n}\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(type, callback, options) {\n  assertCallback(callback);\n  if (typeof options === \"object\" && options !== null) {\n    return {\n      type: String(type),\n      callback: callback !== null && callback !== void 0 ? callback : undefined,\n      capture: Boolean(options.capture)\n    };\n  }\n  return {\n    type: String(type),\n    callback: callback !== null && callback !== void 0 ? callback : undefined,\n    capture: Boolean(options)\n  };\n}\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback) {\n  if (typeof callback === \"function\" || typeof callback === \"object\" && callback !== null && typeof callback.handleEvent === \"function\") {\n    return;\n  }\n  if (callback == null || typeof callback === \"object\") {\n    InvalidEventListener.warn(callback);\n    return;\n  }\n  throw new TypeError(format(InvalidEventListener.message, [callback]));\n}\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(listener, passive, once, signal) {\n  EventListenerWasDuplicated.warn(isCapture(listener) ? \"capture\" : \"bubble\", listener.callback);\n  if (isPassive(listener) !== passive) {\n    OptionWasIgnored.warn(\"passive\");\n  }\n  if (isOnce(listener) !== once) {\n    OptionWasIgnored.warn(\"once\");\n  }\n  if (listener.signal !== signal) {\n    OptionWasIgnored.warn(\"signal\");\n  }\n}\n// Set enumerable\nconst keys$1 = Object.getOwnPropertyNames(EventTarget.prototype);\nfor (let i = 0; i < keys$1.length; ++i) {\n  if (keys$1[i] === \"constructor\") {\n    continue;\n  }\n  Object.defineProperty(EventTarget.prototype, keys$1[i], {\n    enumerable: true\n  });\n}\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.EventTarget !== \"undefined\") {\n  Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype);\n}\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nfunction getEventAttributeValue(target, type) {\n  var _a, _b;\n  const listMap = $$2(target, \"target\");\n  return (_b = (_a = listMap[type]) === null || _a === void 0 ? void 0 : _a.attrCallback) !== null && _b !== void 0 ? _b : null;\n}\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction setEventAttributeValue(target, type, callback) {\n  if (callback != null && typeof callback !== \"function\") {\n    InvalidAttributeHandler.warn(callback);\n  }\n  if (typeof callback === \"function\" || typeof callback === \"object\" && callback !== null) {\n    upsertEventAttributeListener(target, type, callback);\n  } else {\n    removeEventAttributeListener(target, type);\n  }\n}\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener(target, type, callback) {\n  const list = ensureListenerList($$2(target, \"target\"), String(type));\n  list.attrCallback = callback;\n  if (list.attrListener == null) {\n    list.attrListener = addListener(list, defineEventAttributeCallback(list), false, false, false, undefined);\n  }\n}\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(target, type) {\n  const listMap = $$2(target, \"target\");\n  const list = listMap[String(type)];\n  if (list && list.attrListener) {\n    removeListener(list, list.attrListener.callback, false);\n    list.attrCallback = list.attrListener = undefined;\n  }\n}\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(list) {\n  return function (event) {\n    const callback = list.attrCallback;\n    if (typeof callback === \"function\") {\n      callback.call(this, event);\n    }\n  };\n}\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nfunction defineCustomEventTarget(...types) {\n  class CustomEventTarget extends EventTarget {}\n  for (let i = 0; i < types.length; ++i) {\n    defineEventAttribute(CustomEventTarget.prototype, types[i]);\n  }\n  return CustomEventTarget;\n}\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nfunction defineEventAttribute(target, type, _eventClass) {\n  Object.defineProperty(target, `on${type}`, {\n    get() {\n      return getEventAttributeValue(this, type);\n    },\n    set(value) {\n      setEventAttributeValue(this, type, value);\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\nexport default EventTarget;\nexport { Event, EventTarget, defineCustomEventTarget, defineEventAttribute, getEventAttributeValue, setErrorHandler, setEventAttributeValue, setWarningHandler };","map":{"version":3,"names":["assertType","condition","message","args","TypeError","format","i","replace","anyToString","x","String","Object","prototype","toString","call","currentErrorHandler","setErrorHandler","value","undefined","reportError","maybeError","error","Error","dispatchEvent","ErrorEvent","process","emit","console","_a","Global","window","self","global","globalThis","currentWarnHandler","setWarningHandler","Warning","constructor","code","warn","stack","_b","InitEventWasCalledWhileDispatching","FalsyWasAssignedToCancelBubble","TruthyWasAssignedToReturnValue","NonCancelableEventWasCanceled","CanceledInPassiveListener","EventListenerWasDuplicated","OptionWasIgnored","InvalidEventListener","InvalidAttributeHandler","Event","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","type","eventInitDict","defineProperty","enumerable","opts","internalDataMap","set","bubbles","Boolean","cancelable","composed","target","currentTarget","stopPropagationFlag","stopImmediatePropagationFlag","canceledFlag","inPassiveListenerFlag","dispatchFlag","timeStamp","Date","now","$","srcElement","composedPath","eventPhase","stopPropagation","cancelBubble","stopImmediatePropagation","data","returnValue","setCancelFlag","preventDefault","defaultPrevented","isTrusted","initEvent","WeakMap","event","name","retv","get","keys","getOwnPropertyNames","length","setPrototypeOf","createInvalidStateError","DOMException","msg","captureStackTrace","defineProperties","defineErrorCodeProperties","ErrorCodeMap","INDEX_SIZE_ERR","DOMSTRING_SIZE_ERR","HIERARCHY_REQUEST_ERR","WRONG_DOCUMENT_ERR","INVALID_CHARACTER_ERR","NO_DATA_ALLOWED_ERR","NO_MODIFICATION_ALLOWED_ERR","NOT_FOUND_ERR","NOT_SUPPORTED_ERR","INUSE_ATTRIBUTE_ERR","INVALID_STATE_ERR","SYNTAX_ERR","INVALID_MODIFICATION_ERR","NAMESPACE_ERR","INVALID_ACCESS_ERR","VALIDATION_ERR","TYPE_MISMATCH_ERR","SECURITY_ERR","NETWORK_ERR","ABORT_ERR","URL_MISMATCH_ERR","QUOTA_EXCEEDED_ERR","TIMEOUT_ERR","INVALID_NODE_TYPE_ERR","DATA_CLONE_ERR","obj","key","configurable","EventWrapper","wrap","getWrapperClassOf","internalDataMap$1","original","defineRedirectDescriptor","$$1","wrapperClassCache","originalEvent","getPrototypeOf","wrapper","defineWrapper","BaseEventWrapper","originalPrototype","CustomEventWrapper","d","getOwnPropertyDescriptor","bind","createListener","callback","capture","passive","once","signal","signalListener","flags","setRemoved","listener","isCapture","isPassive","isOnce","isRemoved","invokeCallback","handleEvent","thrownError","findIndexOfListener","listeners","addListener","list","removeListener","addEventListener","cow","push","index","removeListenerAt","disableCow","removeEventListener","filter","_","splice","createListenerListMap","create","ensureListenerList","listenerMap","attrCallback","attrListener","EventTarget","internalDataMap$2","type0","callback0","options0","$$2","normalizeAddOptions","aborted","warnDuplicate","normalizeOptions","e","eventData","options","assertCallback","keys$1","getEventAttributeValue","listMap","setEventAttributeValue","upsertEventAttributeListener","removeEventAttributeListener","defineEventAttributeCallback","defineCustomEventTarget","types","CustomEventTarget","defineEventAttribute","_eventClass"],"sources":["../src/lib/misc.ts","../src/lib/error-handler.ts","../src/lib/global.ts","../src/lib/warning-handler.ts","../src/lib/warnings.ts","../src/lib/event.ts","../src/lib/dom-exception.ts","../src/lib/event-wrapper.ts","../src/lib/listener.ts","../src/lib/listener-list.ts","../src/lib/listener-list-map.ts","../src/lib/event-target.ts","../src/lib/event-attribute-handler.ts","../src/lib/legacy.ts"],"sourcesContent":["/**\n * Assert a condition.\n * @param condition The condition that it should satisfy.\n * @param message The error message.\n * @param args The arguments for replacing placeholders in the message.\n */\nexport function assertType(\n    condition: boolean,\n    message: string,\n    ...args: any[]\n): asserts condition {\n    if (!condition) {\n        throw new TypeError(format(message, args))\n    }\n}\n\n/**\n * Convert a text and arguments to one string.\n * @param message The formating text\n * @param args The arguments.\n */\nexport function format(message: string, args: any[]): string {\n    let i = 0\n    return message.replace(/%[os]/gu, () => anyToString(args[i++]))\n}\n\n/**\n * Convert a value to a string representation.\n * @param x The value to get the string representation.\n */\nexport function anyToString(x: any): string {\n    if (typeof x !== \"object\" || x === null) {\n        return String(x)\n    }\n    return Object.prototype.toString.call(x)\n}\n","import { anyToString, assertType } from \"./misc\"\n\ndeclare const console: any\ndeclare const dispatchEvent: any\ndeclare const ErrorEvent: any\ndeclare const process: any\n\nlet currentErrorHandler: setErrorHandler.ErrorHandler | undefined\n\n/**\n * Set the error handler.\n * @param value The error handler to set.\n */\nexport function setErrorHandler(\n    value: setErrorHandler.ErrorHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The error handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentErrorHandler = value\n}\nexport namespace setErrorHandler {\n    /**\n     * The error handler.\n     * @param error The thrown error object.\n     */\n    export type ErrorHandler = (error: Error) => void\n}\n\n/**\n * Print a error message.\n * @param maybeError The error object.\n */\nexport function reportError(maybeError: unknown): void {\n    try {\n        const error =\n            maybeError instanceof Error\n                ? maybeError\n                : new Error(anyToString(maybeError))\n\n        // Call the user-defined error handler if exists.\n        if (currentErrorHandler) {\n            currentErrorHandler(error)\n            return\n        }\n\n        // Dispatch an `error` event if this is on a browser.\n        if (\n            typeof dispatchEvent === \"function\" &&\n            typeof ErrorEvent === \"function\"\n        ) {\n            dispatchEvent(\n                new ErrorEvent(\"error\", { error, message: error.message }),\n            )\n        }\n\n        // Emit an `uncaughtException` event if this is on Node.js.\n        //istanbul ignore else\n        else if (\n            typeof process !== \"undefined\" &&\n            typeof process.emit === \"function\"\n        ) {\n            process.emit(\"uncaughtException\", error)\n            return\n        }\n\n        // Otherwise, print the error.\n        console.error(error)\n    } catch {\n        // ignore.\n    }\n}\n","declare const globalThis: any\ndeclare const window: any\ndeclare const self: any\ndeclare const global: any\n\n/**\n * The global object.\n */\n//istanbul ignore next\nexport const Global: any =\n    typeof window !== \"undefined\"\n        ? window\n        : typeof self !== \"undefined\"\n        ? self\n        : typeof global !== \"undefined\"\n        ? global\n        : typeof globalThis !== \"undefined\"\n        ? globalThis\n        : undefined\n","import { assertType } from \"./misc\"\n\ndeclare const console: any\n\nlet currentWarnHandler: setWarningHandler.WarningHandler | undefined\n\n/**\n * Set the warning handler.\n * @param value The warning handler to set.\n */\nexport function setWarningHandler(\n    value: setWarningHandler.WarningHandler | undefined,\n): void {\n    assertType(\n        typeof value === \"function\" || value === undefined,\n        \"The warning handler must be a function or undefined, but got %o.\",\n        value,\n    )\n    currentWarnHandler = value\n}\nexport namespace setWarningHandler {\n    /**\n     * The warning information.\n     */\n    export interface Warning {\n        /**\n         * The code of this warning.\n         */\n        code: string\n        /**\n         * The message in English.\n         */\n        message: string\n        /**\n         * The arguments for replacing placeholders in the text.\n         */\n        args: any[]\n    }\n\n    /**\n     * The warning handler.\n     * @param warning The warning.\n     */\n    export type WarningHandler = (warning: Warning) => void\n}\n\n/**\n * The warning information.\n */\nexport class Warning<TArgs extends any[]> {\n    readonly code: string\n    readonly message: string\n\n    constructor(code: string, message: string) {\n        this.code = code\n        this.message = message\n    }\n\n    /**\n     * Report this warning.\n     * @param args The arguments of the warning.\n     */\n    warn(...args: TArgs): void {\n        try {\n            // Call the user-defined warning handler if exists.\n            if (currentWarnHandler) {\n                currentWarnHandler({ ...this, args })\n                return\n            }\n\n            // Otherwise, print the warning.\n            const stack = (new Error().stack ?? \"\").replace(\n                /^(?:.+?\\n){2}/gu,\n                \"\\n\",\n            )\n            console.warn(this.message, ...args, stack)\n        } catch {\n            // Ignore.\n        }\n    }\n}\n","import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Warning } from \"./warning-handler\"\n\nexport const InitEventWasCalledWhileDispatching = new Warning<[]>(\n    \"W01\",\n    \"Unable to initialize event under dispatching.\",\n)\n\nexport const FalsyWasAssignedToCancelBubble = new Warning<[]>(\n    \"W02\",\n    \"Assigning any falsy value to 'cancelBubble' property has no effect.\",\n)\n\nexport const TruthyWasAssignedToReturnValue = new Warning<[]>(\n    \"W03\",\n    \"Assigning any truthy value to 'returnValue' property has no effect.\",\n)\n\nexport const NonCancelableEventWasCanceled = new Warning<[]>(\n    \"W04\",\n    \"Unable to preventDefault on non-cancelable events.\",\n)\n\nexport const CanceledInPassiveListener = new Warning<[]>(\n    \"W05\",\n    \"Unable to preventDefault inside passive event listener invocation.\",\n)\n\nexport const EventListenerWasDuplicated = new Warning<\n    [type: \"bubble\" | \"capture\", callback: EventTarget.EventListener<any, any>]\n>(\n    \"W06\",\n    \"An event listener wasn't added because it has been added already: %o, %o\",\n)\n\nexport const OptionWasIgnored = new Warning<\n    [name: \"passive\" | \"once\" | \"signal\"]\n>(\n    \"W07\",\n    \"The %o option value was abandoned because the event listener wasn't added as duplicated.\",\n)\n\nexport const InvalidEventListener = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {} | null | undefined]\n>(\n    \"W08\",\n    \"The 'callback' argument must be a function or an object that has 'handleEvent' method: %o\",\n)\n\nexport const InvalidAttributeHandler = new Warning<\n    [callback: EventTarget.EventListener<any, any> | {}]\n>(\"W09\", \"Event attribute handler must be a function: %o\")\n","import { EventTarget } from \"./event-target\" // Used as only type, so no circular.\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\nimport {\n    CanceledInPassiveListener,\n    FalsyWasAssignedToCancelBubble,\n    InitEventWasCalledWhileDispatching,\n    NonCancelableEventWasCanceled,\n    TruthyWasAssignedToReturnValue,\n} from \"./warnings\"\n\n/*eslint-disable class-methods-use-this */\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * `EventTarget` shim can control the internal state of this `Event` objects.\n * @see https://dom.spec.whatwg.org/#event\n */\nexport class Event<TEventType extends string = string> {\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    static get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    static get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    static get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    static get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * Initialize this event instance.\n     * @param type The type of this event.\n     * @param eventInitDict Options to initialize.\n     * @see https://dom.spec.whatwg.org/#dom-event-event\n     */\n    constructor(type: TEventType, eventInitDict?: Event.EventInit) {\n        Object.defineProperty(this, \"isTrusted\", {\n            value: false,\n            enumerable: true,\n        })\n\n        const opts = eventInitDict ?? {}\n        internalDataMap.set(this, {\n            type: String(type),\n            bubbles: Boolean(opts.bubbles),\n            cancelable: Boolean(opts.cancelable),\n            composed: Boolean(opts.composed),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n            inPassiveListenerFlag: false,\n            dispatchFlag: false,\n            timeStamp: Date.now(),\n        })\n    }\n\n    /**\n     * The type of this event.\n     * @see https://dom.spec.whatwg.org/#dom-event-type\n     */\n    get type(): TEventType {\n        return $(this).type as TEventType\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    get target(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @deprecated Use the `target` property instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-srcelement\n     */\n    get srcElement(): EventTarget | null {\n        return $(this).target\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    get currentTarget(): EventTarget | null {\n        return $(this).currentTarget\n    }\n\n    /**\n     * The event target of the current dispatching.\n     * This doesn't support node tree.\n     * @see https://dom.spec.whatwg.org/#dom-event-composedpath\n     */\n    composedPath(): EventTarget[] {\n        const currentTarget = $(this).currentTarget\n        if (currentTarget) {\n            return [currentTarget]\n        }\n        return []\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-none\n     */\n    get NONE(): number {\n        return NONE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-capturing_phase\n     */\n    get CAPTURING_PHASE(): number {\n        return CAPTURING_PHASE\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-at_target\n     */\n    get AT_TARGET(): number {\n        return AT_TARGET\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbling_phase\n     */\n    get BUBBLING_PHASE(): number {\n        return BUBBLING_PHASE\n    }\n\n    /**\n     * The current event phase.\n     * @see https://dom.spec.whatwg.org/#dom-event-eventphase\n     */\n    get eventPhase(): number {\n        return $(this).dispatchFlag ? 2 : 0\n    }\n\n    /**\n     * Stop event bubbling.\n     * Because this shim doesn't support node tree, this merely changes the `cancelBubble` property value.\n     * @see https://dom.spec.whatwg.org/#dom-event-stoppropagation\n     */\n    stopPropagation(): void {\n        $(this).stopPropagationFlag = true\n    }\n\n    /**\n     * `true` if event bubbling was stopped.\n     * @deprecated\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    get cancelBubble(): boolean {\n        return $(this).stopPropagationFlag\n    }\n\n    /**\n     * Stop event bubbling if `true` is set.\n     * @deprecated Use the `stopPropagation()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelbubble\n     */\n    set cancelBubble(value: boolean) {\n        if (value) {\n            $(this).stopPropagationFlag = true\n        } else {\n            FalsyWasAssignedToCancelBubble.warn()\n        }\n    }\n\n    /**\n     * Stop event bubbling and subsequent event listener callings.\n     * @see https://dom.spec.whatwg.org/#dom-event-stopimmediatepropagation\n     */\n    stopImmediatePropagation(): void {\n        const data = $(this)\n        data.stopPropagationFlag = data.stopImmediatePropagationFlag = true\n    }\n\n    /**\n     * `true` if this event will bubble.\n     * @see https://dom.spec.whatwg.org/#dom-event-bubbles\n     */\n    get bubbles(): boolean {\n        return $(this).bubbles\n    }\n\n    /**\n     * `true` if this event can be canceled by the `preventDefault()` method.\n     * @see https://dom.spec.whatwg.org/#dom-event-cancelable\n     */\n    get cancelable(): boolean {\n        return $(this).cancelable\n    }\n\n    /**\n     * `true` if the default behavior will act.\n     * @deprecated Use the `defaultPrevented` proeprty instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    get returnValue(): boolean {\n        return !$(this).canceledFlag\n    }\n\n    /**\n     * Cancel the default behavior if `false` is set.\n     * @deprecated Use the `preventDefault()` method instead.\n     * @see https://dom.spec.whatwg.org/#dom-event-returnvalue\n     */\n    set returnValue(value: boolean) {\n        if (!value) {\n            setCancelFlag($(this))\n        } else {\n            TruthyWasAssignedToReturnValue.warn()\n        }\n    }\n\n    /**\n     * Cancel the default behavior.\n     * @see https://dom.spec.whatwg.org/#dom-event-preventdefault\n     */\n    preventDefault(): void {\n        setCancelFlag($(this))\n    }\n\n    /**\n     * `true` if the default behavior was canceled.\n     * @see https://dom.spec.whatwg.org/#dom-event-defaultprevented\n     */\n    get defaultPrevented(): boolean {\n        return $(this).canceledFlag\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    get composed(): boolean {\n        return $(this).composed\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-istrusted\n     */\n    //istanbul ignore next\n    get isTrusted(): boolean {\n        return false\n    }\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-timestamp\n     */\n    get timeStamp(): number {\n        return $(this).timeStamp\n    }\n\n    /**\n     * @deprecated Don't use this method. The constructor did initialization.\n     */\n    initEvent(type: string, bubbles = false, cancelable = false) {\n        const data = $(this)\n        if (data.dispatchFlag) {\n            InitEventWasCalledWhileDispatching.warn()\n            return\n        }\n\n        internalDataMap.set(this, {\n            ...data,\n            type: String(type),\n            bubbles: Boolean(bubbles),\n            cancelable: Boolean(cancelable),\n            target: null,\n            currentTarget: null,\n            stopPropagationFlag: false,\n            stopImmediatePropagationFlag: false,\n            canceledFlag: false,\n        })\n    }\n}\n\n/*eslint-enable class-methods-use-this */\n\nexport namespace Event {\n    /**\n     * The options of the `Event` constructor.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventinit\n     */\n    export interface EventInit {\n        bubbles?: boolean\n        cancelable?: boolean\n        composed?: boolean\n    }\n}\n\nexport { $ as getEventInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NONE = 0\nconst CAPTURING_PHASE = 1\nconst AT_TARGET = 2\nconst BUBBLING_PHASE = 3\n\n/**\n * Private data.\n */\ninterface EventInternalData {\n    /**\n     * The value of `type` attribute.\n     */\n    readonly type: string\n    /**\n     * The value of `bubbles` attribute.\n     */\n    readonly bubbles: boolean\n    /**\n     * The value of `cancelable` attribute.\n     */\n    readonly cancelable: boolean\n    /**\n     * The value of `composed` attribute.\n     */\n    readonly composed: boolean\n    /**\n     * The value of `timeStamp` attribute.\n     */\n    readonly timeStamp: number\n\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-target\n     */\n    target: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#dom-event-currenttarget\n     */\n    currentTarget: EventTarget | null\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-propagation-flag\n     */\n    stopPropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#stop-immediate-propagation-flag\n     */\n    stopImmediatePropagationFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#canceled-flag\n     */\n    canceledFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#in-passive-listener-flag\n     */\n    inPassiveListenerFlag: boolean\n    /**\n     * @see https://dom.spec.whatwg.org/#dispatch-flag\n     */\n    dispatchFlag: boolean\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(event: unknown, name = \"this\"): EventInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that Event constructor created, but got another one: %o\",\n        name,\n        event,\n    )\n    return retv\n}\n\n/**\n * https://dom.spec.whatwg.org/#set-the-canceled-flag\n * @param data private data.\n */\nfunction setCancelFlag(data: EventInternalData) {\n    if (data.inPassiveListenerFlag) {\n        CanceledInPassiveListener.warn()\n        return\n    }\n    if (!data.cancelable) {\n        NonCancelableEventWasCanceled.warn()\n        return\n    }\n\n    data.canceledFlag = true\n}\n\n// Set enumerable\nObject.defineProperty(Event, \"NONE\", { enumerable: true })\nObject.defineProperty(Event, \"CAPTURING_PHASE\", { enumerable: true })\nObject.defineProperty(Event, \"AT_TARGET\", { enumerable: true })\nObject.defineProperty(Event, \"BUBBLING_PHASE\", { enumerable: true })\nconst keys = Object.getOwnPropertyNames(Event.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(Event.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `event instanceof window.Event` is `true`.\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    Object.setPrototypeOf(Event.prototype, Global.Event.prototype)\n}\n","import { Global } from \"./global\"\n\n/**\n * Create a new InvalidStateError instance.\n * @param message The error message.\n */\nexport function createInvalidStateError(message: string): Error {\n    if (Global.DOMException) {\n        return new Global.DOMException(message, \"InvalidStateError\")\n    }\n\n    if (DOMException == null) {\n        DOMException = class DOMException extends Error {\n            constructor(msg: string) {\n                super(msg)\n                if ((Error as any).captureStackTrace) {\n                    ;(Error as any).captureStackTrace(this, DOMException)\n                }\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get code() {\n                return 11\n            }\n            // eslint-disable-next-line class-methods-use-this\n            get name() {\n                return \"InvalidStateError\"\n            }\n        }\n        Object.defineProperties(DOMException.prototype, {\n            code: { enumerable: true },\n            name: { enumerable: true },\n        })\n        defineErrorCodeProperties(DOMException)\n        defineErrorCodeProperties(DOMException.prototype)\n    }\n    return new DOMException(message)\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nlet DOMException: { new (message: string): Error } | undefined\n\nconst ErrorCodeMap = {\n    INDEX_SIZE_ERR: 1,\n    DOMSTRING_SIZE_ERR: 2,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    INVALID_CHARACTER_ERR: 5,\n    NO_DATA_ALLOWED_ERR: 6,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INUSE_ATTRIBUTE_ERR: 10,\n    INVALID_STATE_ERR: 11,\n    SYNTAX_ERR: 12,\n    INVALID_MODIFICATION_ERR: 13,\n    NAMESPACE_ERR: 14,\n    INVALID_ACCESS_ERR: 15,\n    VALIDATION_ERR: 16,\n    TYPE_MISMATCH_ERR: 17,\n    SECURITY_ERR: 18,\n    NETWORK_ERR: 19,\n    ABORT_ERR: 20,\n    URL_MISMATCH_ERR: 21,\n    QUOTA_EXCEEDED_ERR: 22,\n    TIMEOUT_ERR: 23,\n    INVALID_NODE_TYPE_ERR: 24,\n    DATA_CLONE_ERR: 25,\n}\ntype ErrorCodeMap = typeof ErrorCodeMap\n\nfunction defineErrorCodeProperties(obj: any): void {\n    const keys = Object.keys(ErrorCodeMap) as (keyof ErrorCodeMap)[]\n    for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i]\n        const value = ErrorCodeMap[key]\n        Object.defineProperty(obj, key, {\n            get() {\n                return value\n            },\n            configurable: true,\n            enumerable: true,\n        })\n    }\n}\n","import { Event } from \"./event\"\nimport { Global } from \"./global\"\nimport { assertType } from \"./misc\"\n\n/**\n * An implementation of `Event` interface, that wraps a given event object.\n * This class controls the internal state of `Event`.\n * @see https://dom.spec.whatwg.org/#interface-event\n */\nexport class EventWrapper<TEventType extends string> extends Event<TEventType> {\n    /**\n     * Wrap a given event object to control states.\n     * @param event The event-like object to wrap.\n     */\n    static wrap<T extends EventLike>(event: T): EventWrapperOf<T> {\n        return new (getWrapperClassOf(event))(event)\n    }\n\n    protected constructor(event: Event<TEventType>) {\n        super(event.type, {\n            bubbles: event.bubbles,\n            cancelable: event.cancelable,\n            composed: event.composed,\n        })\n\n        if (event.cancelBubble) {\n            super.stopPropagation()\n        }\n        if (event.defaultPrevented) {\n            super.preventDefault()\n        }\n\n        internalDataMap.set(this, { original: event })\n\n        // Define accessors\n        const keys = Object.keys(event)\n        for (let i = 0; i < keys.length; ++i) {\n            const key = keys[i]\n            if (!(key in this)) {\n                Object.defineProperty(\n                    this,\n                    key,\n                    defineRedirectDescriptor(event, key),\n                )\n            }\n        }\n    }\n\n    stopPropagation(): void {\n        super.stopPropagation()\n\n        const { original } = $(this)\n        if (\"stopPropagation\" in original) {\n            original.stopPropagation!()\n        }\n    }\n\n    get cancelBubble(): boolean {\n        return super.cancelBubble\n    }\n    set cancelBubble(value: boolean) {\n        super.cancelBubble = value\n\n        const { original } = $(this)\n        if (\"cancelBubble\" in original) {\n            original.cancelBubble = value\n        }\n    }\n\n    stopImmediatePropagation(): void {\n        super.stopImmediatePropagation()\n\n        const { original } = $(this)\n        if (\"stopImmediatePropagation\" in original) {\n            original.stopImmediatePropagation!()\n        }\n    }\n\n    get returnValue(): boolean {\n        return super.returnValue\n    }\n    set returnValue(value: boolean) {\n        super.returnValue = value\n\n        const { original } = $(this)\n        if (\"returnValue\" in original) {\n            original.returnValue = value\n        }\n    }\n\n    preventDefault(): void {\n        super.preventDefault()\n\n        const { original } = $(this)\n        if (\"preventDefault\" in original) {\n            original.preventDefault!()\n        }\n    }\n\n    get timeStamp(): number {\n        const { original } = $(this)\n        if (\"timeStamp\" in original) {\n            return original.timeStamp!\n        }\n        return super.timeStamp\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\ntype EventLike = { readonly type: string } & Partial<Event>\ntype EventWrapperOf<T extends EventLike> = Event<T[\"type\"]> &\n    Omit<T, keyof Event>\n\ninterface EventWrapperInternalData {\n    readonly original: EventLike\n}\n\n/**\n * Private data for event wrappers.\n */\nconst internalDataMap = new WeakMap<any, EventWrapperInternalData>()\n\n/**\n * Get private data.\n * @param event The event object to get private data.\n * @returns The private data of the event.\n */\nfunction $(event: unknown): EventWrapperInternalData {\n    const retv = internalDataMap.get(event)\n    assertType(\n        retv != null,\n        \"'this' is expected an Event object, but got\",\n        event,\n    )\n    return retv\n}\n\n/**\n * Cache for wrapper classes.\n * @type {WeakMap<Object, Function>}\n * @private\n */\nconst wrapperClassCache = new WeakMap()\n\n// Make association for wrappers.\nwrapperClassCache.set(Object.prototype, EventWrapper)\nif (typeof Global !== \"undefined\" && typeof Global.Event !== \"undefined\") {\n    wrapperClassCache.set(Global.Event.prototype, EventWrapper)\n}\n\n/**\n * Get the wrapper class of a given prototype.\n * @param originalEvent The event object to wrap.\n */\nfunction getWrapperClassOf<T extends EventLike>(\n    originalEvent: T,\n): { new (e: T): EventWrapperOf<T> } {\n    const prototype = Object.getPrototypeOf(originalEvent)\n    if (prototype == null) {\n        return EventWrapper as any\n    }\n\n    let wrapper: any = wrapperClassCache.get(prototype)\n    if (wrapper == null) {\n        wrapper = defineWrapper(getWrapperClassOf(prototype), prototype)\n        wrapperClassCache.set(prototype, wrapper)\n    }\n\n    return wrapper\n}\n\n/**\n * Define new wrapper class.\n * @param BaseEventWrapper The base wrapper class.\n * @param originalPrototype The prototype of the original event.\n */\nfunction defineWrapper(BaseEventWrapper: any, originalPrototype: any): any {\n    class CustomEventWrapper extends BaseEventWrapper {}\n\n    const keys = Object.keys(originalPrototype)\n    for (let i = 0; i < keys.length; ++i) {\n        Object.defineProperty(\n            CustomEventWrapper.prototype,\n            keys[i],\n            defineRedirectDescriptor(originalPrototype, keys[i]),\n        )\n    }\n\n    return CustomEventWrapper\n}\n\n/**\n * Get the property descriptor to redirect a given property.\n */\nfunction defineRedirectDescriptor(obj: any, key: string): PropertyDescriptor {\n    const d = Object.getOwnPropertyDescriptor(obj, key)!\n    return {\n        get() {\n            const original: any = $(this).original\n            const value = original[key]\n            if (typeof value === \"function\") {\n                return value.bind(original)\n            }\n            return value\n        },\n        set(value: any) {\n            const original: any = $(this).original\n            original[key] = value\n        },\n        configurable: d.configurable,\n        enumerable: d.enumerable,\n    }\n}\n","import { reportError } from \"./error-handler\"\nimport { Event } from \"./event\" // Used as only type, so no circular.\nimport { EventTarget } from \"./event-target\" // Used as only type, so no circular.\n\n/**\n * The event listener concept.\n * @see https://dom.spec.whatwg.org/#concept-event-listener\n */\nexport interface Listener {\n    /**\n     * The callback function.\n     */\n    readonly callback: Listener.Callback<any, any>\n    /**\n     * The flags of this listener.\n     * This is writable to add the removed flag.\n     */\n    flags: ListenerFlags\n    /**\n     * The `AbortSignal` to remove this listener.\n     */\n    readonly signal: Listener.AbortSignal | undefined\n    /**\n     * The `abort` event listener for the `signal`.\n     * To remove it from the `signal`.\n     */\n    readonly signalListener: (() => void) | undefined\n}\n\nexport namespace Listener {\n    export type Callback<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    export interface AbortSignal {\n        addEventListener(type: string, callback: Callback<any, Event>): void\n        removeEventListener(type: string, callback: Callback<any, Event>): void\n    }\n}\n\n/**\n * Create a new listener.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n * @param signalListener The abort event listener for the abort signal.\n */\nexport function createListener(\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n    signalListener: (() => void) | undefined,\n): Listener {\n    return {\n        callback,\n        flags:\n            (capture ? ListenerFlags.Capture : 0) |\n            (passive ? ListenerFlags.Passive : 0) |\n            (once ? ListenerFlags.Once : 0),\n        signal,\n        signalListener,\n    }\n}\n\n/**\n * Set the `removed` flag to the given listener.\n * @param listener The listener to check.\n */\nexport function setRemoved(listener: Listener): void {\n    listener.flags |= ListenerFlags.Removed\n}\n\n/**\n * Check if the given listener has the `capture` flag or not.\n * @param listener The listener to check.\n */\nexport function isCapture(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Capture) === ListenerFlags.Capture\n}\n\n/**\n * Check if the given listener has the `passive` flag or not.\n * @param listener The listener to check.\n */\nexport function isPassive(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Passive) === ListenerFlags.Passive\n}\n\n/**\n * Check if the given listener has the `once` flag or not.\n * @param listener The listener to check.\n */\nexport function isOnce(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Once) === ListenerFlags.Once\n}\n\n/**\n * Check if the given listener has the `removed` flag or not.\n * @param listener The listener to check.\n */\nexport function isRemoved(listener: Listener): boolean {\n    return (listener.flags & ListenerFlags.Removed) === ListenerFlags.Removed\n}\n\n/**\n * Call an event listener.\n * @param listener The listener to call.\n * @param target The event target object for `thisArg`.\n * @param event The event object for the first argument.\n * @param attribute `true` if this callback is an event attribute handler.\n */\nexport function invokeCallback(\n    { callback }: Listener,\n    target: EventTarget<any, any>,\n    event: Event<any>,\n): void {\n    try {\n        if (typeof callback === \"function\") {\n            callback.call(target, event)\n        } else if (typeof callback.handleEvent === \"function\") {\n            callback.handleEvent(event)\n        }\n    } catch (thrownError) {\n        reportError(thrownError)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * The flags of listeners.\n */\nconst enum ListenerFlags {\n    Capture = 0x01,\n    Passive = 0x02,\n    Once = 0x04,\n    Removed = 0x08,\n}\n","import { createListener, isCapture, Listener, setRemoved } from \"./listener\"\n\n/**\n * Information of an listener list.\n */\nexport interface ListenerList {\n    /**\n     * The callback function of the event attribute handler.\n     */\n    attrCallback: Listener.CallbackFunction<any, any> | undefined\n    /**\n     * The listener of the event attribute handler.\n     */\n    attrListener: Listener | undefined\n    /**\n     * `true` if the `dispatchEvent` method is traversing the current `listeners` array.\n     */\n    cow: boolean\n    /**\n     * The listeners.\n     * This is writable for copy-on-write.\n     */\n    listeners: Listener[]\n}\n\n/**\n * Find the index of given listener.\n * This returns `-1` if not found.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n */\nexport function findIndexOfListener(\n    { listeners }: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): number {\n    for (let i = 0; i < listeners.length; ++i) {\n        if (\n            listeners[i].callback === callback &&\n            isCapture(listeners[i]) === capture\n        ) {\n            return i\n        }\n    }\n    return -1\n}\n\n/**\n * Add the given listener.\n * Does copy-on-write if needed.\n * @param list The listener list.\n * @param callback The callback function.\n * @param capture The capture flag.\n * @param passive The passive flag.\n * @param once The once flag.\n * @param signal The abort signal.\n */\nexport function addListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n    passive: boolean,\n    once: boolean,\n    signal: Listener.AbortSignal | undefined,\n): Listener {\n    let signalListener: (() => void) | undefined\n    if (signal) {\n        signalListener = removeListener.bind(null, list, callback, capture)\n        signal.addEventListener(\"abort\", signalListener)\n    }\n\n    const listener = createListener(\n        callback,\n        capture,\n        passive,\n        once,\n        signal,\n        signalListener,\n    )\n\n    if (list.cow) {\n        list.cow = false\n        list.listeners = [...list.listeners, listener]\n    } else {\n        list.listeners.push(listener)\n    }\n\n    return listener\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param callback The callback function to find.\n * @param capture The capture flag to find.\n * @returns `true` if it mutated the list directly.\n */\nexport function removeListener(\n    list: ListenerList,\n    callback: Listener.Callback<any, any>,\n    capture: boolean,\n): boolean {\n    const index = findIndexOfListener(list, callback, capture)\n    if (index !== -1) {\n        return removeListenerAt(list, index)\n    }\n    return false\n}\n\n/**\n * Remove a listener.\n * @param list The listener list.\n * @param index The index of the target listener.\n * @param disableCow Disable copy-on-write if true.\n * @returns `true` if it mutated the `listeners` array directly.\n */\nexport function removeListenerAt(\n    list: ListenerList,\n    index: number,\n    disableCow = false,\n): boolean {\n    const listener = list.listeners[index]\n\n    // Set the removed flag.\n    setRemoved(listener)\n\n    // Dispose the abort signal listener if exists.\n    if (listener.signal) {\n        listener.signal.removeEventListener(\"abort\", listener.signalListener!)\n    }\n\n    // Remove it from the array.\n    if (list.cow && !disableCow) {\n        list.cow = false\n        list.listeners = list.listeners.filter((_, i) => i !== index)\n        return false\n    }\n    list.listeners.splice(index, 1)\n    return true\n}\n","import { ListenerList } from \"./listener-list\"\n\n/**\n * The map from event types to each listener list.\n */\nexport interface ListenerListMap {\n    [type: string]: ListenerList | undefined\n}\n\n/**\n * Create a new `ListenerListMap` object.\n */\nexport function createListenerListMap(): ListenerListMap {\n    return Object.create(null)\n}\n\n/**\n * Get the listener list of the given type.\n * If the listener list has not been initialized, initialize and return it.\n * @param listenerMap The listener list map.\n * @param type The event type to get.\n */\nexport function ensureListenerList(\n    listenerMap: Record<string, ListenerList | undefined>,\n    type: string,\n): ListenerList {\n    return (listenerMap[type] ??= {\n        attrCallback: undefined,\n        attrListener: undefined,\n        cow: false,\n        listeners: [],\n    })\n}\n","import { createInvalidStateError } from \"./dom-exception\"\nimport { Event, getEventInternalData } from \"./event\"\nimport { EventWrapper } from \"./event-wrapper\"\nimport { Global } from \"./global\"\nimport {\n    invokeCallback,\n    isCapture,\n    isOnce,\n    isPassive,\n    isRemoved,\n    Listener,\n} from \"./listener\"\nimport {\n    addListener,\n    findIndexOfListener,\n    removeListener,\n    removeListenerAt,\n} from \"./listener-list\"\nimport {\n    createListenerListMap,\n    ensureListenerList,\n    ListenerListMap,\n} from \"./listener-list-map\"\nimport { assertType, format } from \"./misc\"\nimport {\n    EventListenerWasDuplicated,\n    InvalidEventListener,\n    OptionWasIgnored,\n} from \"./warnings\"\n\n/**\n * An implementation of the `EventTarget` interface.\n * @see https://dom.spec.whatwg.org/#eventtarget\n */\nexport class EventTarget<\n    TEventMap extends Record<string, Event> = Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n> {\n    /**\n     * Initialize this instance.\n     */\n    constructor() {\n        internalDataMap.set(this, createListenerListMap())\n    }\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    addEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.AddOptions,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Add an event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    addEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    addEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.AddOptions,\n    ): void {\n        const listenerMap = $(this)\n        const {\n            callback,\n            capture,\n            once,\n            passive,\n            signal,\n            type,\n        } = normalizeAddOptions(type0, callback0, options0)\n        if (callback == null || signal?.aborted) {\n            return\n        }\n        const list = ensureListenerList(listenerMap, type)\n\n        // Find existing listener.\n        const i = findIndexOfListener(list, callback, capture)\n        if (i !== -1) {\n            warnDuplicate(list.listeners[i], passive, once, signal)\n            return\n        }\n\n        // Add the new listener.\n        addListener(list, callback, capture, passive, once, signal)\n    }\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param options Options.\n     */\n    removeEventListener(\n        type: string,\n        callback?: EventTarget.FallbackEventListener<this, TMode>,\n        options?: EventTarget.Options,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener<T extends string & keyof TEventMap>(\n        type: T,\n        callback:\n            | EventTarget.EventListener<this, TEventMap[T]>\n            | null\n            | undefined,\n        capture: boolean,\n    ): void\n\n    /**\n     * Remove an added event listener.\n     * @param type The event type.\n     * @param callback The event listener.\n     * @param capture The capture flag.\n     * @deprecated Use `{capture: boolean}` object instead of a boolean value.\n     */\n    removeEventListener(\n        type: string,\n        callback: EventTarget.FallbackEventListener<this, TMode>,\n        capture: boolean,\n    ): void\n\n    // Implementation\n    removeEventListener<T extends string & keyof TEventMap>(\n        type0: T,\n        callback0?: EventTarget.EventListener<this, TEventMap[T]> | null,\n        options0?: boolean | EventTarget.Options,\n    ): void {\n        const listenerMap = $(this)\n        const { callback, capture, type } = normalizeOptions(\n            type0,\n            callback0,\n            options0,\n        )\n        const list = listenerMap[type]\n\n        if (callback != null && list) {\n            removeListener(list, callback, capture)\n        }\n    }\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent<T extends string & keyof TEventMap>(\n        event: EventTarget.EventData<TEventMap, TMode, T>,\n    ): boolean\n\n    /**\n     * Dispatch an event.\n     * @param event The `Event` object to dispatch.\n     */\n    dispatchEvent(event: EventTarget.FallbackEvent<TMode>): boolean\n\n    // Implementation\n    dispatchEvent(\n        e:\n            | EventTarget.EventData<TEventMap, TMode, string>\n            | EventTarget.FallbackEvent<TMode>,\n    ): boolean {\n        const list = $(this)[String(e.type)]\n        if (list == null) {\n            return true\n        }\n\n        const event = e instanceof Event ? e : EventWrapper.wrap(e)\n        const eventData = getEventInternalData(event, \"event\")\n        if (eventData.dispatchFlag) {\n            throw createInvalidStateError(\"This event has been in dispatching.\")\n        }\n\n        eventData.dispatchFlag = true\n        eventData.target = eventData.currentTarget = this\n\n        if (!eventData.stopPropagationFlag) {\n            const { cow, listeners } = list\n\n            // Set copy-on-write flag.\n            list.cow = true\n\n            // Call listeners.\n            for (let i = 0; i < listeners.length; ++i) {\n                const listener = listeners[i]\n\n                // Skip if removed.\n                if (isRemoved(listener)) {\n                    continue\n                }\n\n                // Remove this listener if has the `once` flag.\n                if (isOnce(listener) && removeListenerAt(list, i, !cow)) {\n                    // Because this listener was removed, the next index is the\n                    // same as the current value.\n                    i -= 1\n                }\n\n                // Call this listener with the `passive` flag.\n                eventData.inPassiveListenerFlag = isPassive(listener)\n                invokeCallback(listener, this, event)\n                eventData.inPassiveListenerFlag = false\n\n                // Stop if the `event.stopImmediatePropagation()` method was called.\n                if (eventData.stopImmediatePropagationFlag) {\n                    break\n                }\n            }\n\n            // Restore copy-on-write flag.\n            if (!cow) {\n                list.cow = false\n            }\n        }\n\n        eventData.target = null\n        eventData.currentTarget = null\n        eventData.stopImmediatePropagationFlag = false\n        eventData.stopPropagationFlag = false\n        eventData.dispatchFlag = false\n\n        return !eventData.canceledFlag\n    }\n}\n\nexport namespace EventTarget {\n    /**\n     * The event listener.\n     */\n    export type EventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > = CallbackFunction<TEventTarget, TEvent> | CallbackObject<TEvent>\n\n    /**\n     * The event listener function.\n     */\n    export interface CallbackFunction<\n        TEventTarget extends EventTarget<any, any>,\n        TEvent extends Event\n    > {\n        (this: TEventTarget, event: TEvent): void\n    }\n\n    /**\n     * The event listener object.\n     * @see https://dom.spec.whatwg.org/#callbackdef-eventlistener\n     */\n    export interface CallbackObject<TEvent extends Event> {\n        handleEvent(event: TEvent): void\n    }\n\n    /**\n     * The common options for both `addEventListener` and `removeEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-eventlisteneroptions\n     */\n    export interface Options {\n        capture?: boolean\n    }\n\n    /**\n     * The options for the `addEventListener` methods.\n     * @see https://dom.spec.whatwg.org/#dictdef-addeventlisteneroptions\n     */\n    export interface AddOptions extends Options {\n        passive?: boolean\n        once?: boolean\n        signal?: AbortSignal | null | undefined\n    }\n\n    /**\n     * The abort signal.\n     * @see https://dom.spec.whatwg.org/#abortsignal\n     */\n    export interface AbortSignal extends EventTarget<{ abort: Event }> {\n        readonly aborted: boolean\n        onabort: CallbackFunction<this, Event> | null\n    }\n\n    /**\n     * The event data to dispatch in strict mode.\n     */\n    export type EventData<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\",\n        TEventType extends string\n    > = TMode extends \"strict\"\n        ? IsValidEventMap<TEventMap> extends true\n            ? ExplicitType<TEventType> &\n                  Omit<TEventMap[TEventType], keyof Event> &\n                  Partial<Omit<Event, \"type\">>\n            : never\n        : never\n\n    /**\n     * Define explicit `type` property if `T` is a string literal.\n     * Otherwise, never.\n     */\n    export type ExplicitType<T extends string> = string extends T\n        ? never\n        : { readonly type: T }\n\n    /**\n     * The event listener type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEventListener<\n        TEventTarget extends EventTarget<any, any>,\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\"\n        ? EventListener<TEventTarget, Event> | null | undefined\n        : never\n\n    /**\n     * The event type in standard mode.\n     * Otherwise, never.\n     */\n    export type FallbackEvent<\n        TMode extends \"standard\" | \"strict\"\n    > = TMode extends \"standard\" ? Event : never\n\n    /**\n     * Check if given event map is valid.\n     * It's valid if the keys of the event map are narrower than `string`.\n     */\n    export type IsValidEventMap<T> = string extends keyof T ? false : true\n}\n\nexport { $ as getEventTargetInternalData }\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Internal data for EventTarget\n */\ntype EventTargetInternalData = ListenerListMap\n\n/**\n * Internal data.\n */\nconst internalDataMap = new WeakMap<any, EventTargetInternalData>()\n\n/**\n * Get private data.\n * @param target The event target object to get private data.\n * @param name The variable name to report.\n * @returns The private data of the event.\n */\nfunction $(target: any, name = \"this\"): EventTargetInternalData {\n    const retv = internalDataMap.get(target)\n    assertType(\n        retv != null,\n        \"'%s' must be an object that EventTarget constructor created, but got another one: %o\",\n        name,\n        target,\n    )\n    return retv\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeAddOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.AddOptions | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n    passive: boolean\n    once: boolean\n    signal: EventTarget.AbortSignal | undefined\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n            passive: Boolean(options.passive),\n            once: Boolean(options.once),\n            signal: options.signal ?? undefined,\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n        passive: false,\n        once: false,\n        signal: undefined,\n    }\n}\n\n/**\n * Normalize options.\n * @param options The options to normalize.\n */\nfunction normalizeOptions(\n    type: string,\n    callback: EventTarget.EventListener<any, any> | null | undefined,\n    options: boolean | EventTarget.Options | undefined,\n): {\n    type: string\n    callback: EventTarget.EventListener<any, any> | undefined\n    capture: boolean\n} {\n    assertCallback(callback)\n\n    if (typeof options === \"object\" && options !== null) {\n        return {\n            type: String(type),\n            callback: callback ?? undefined,\n            capture: Boolean(options.capture),\n        }\n    }\n\n    return {\n        type: String(type),\n        callback: callback ?? undefined,\n        capture: Boolean(options),\n    }\n}\n\n/**\n * Assert the type of 'callback' argument.\n * @param callback The callback to check.\n */\nfunction assertCallback(callback: any): void {\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" &&\n            callback !== null &&\n            typeof callback.handleEvent === \"function\")\n    ) {\n        return\n    }\n    if (callback == null || typeof callback === \"object\") {\n        InvalidEventListener.warn(callback)\n        return\n    }\n\n    throw new TypeError(format(InvalidEventListener.message, [callback]))\n}\n\n/**\n * Print warning for duplicated.\n * @param listener The current listener that is duplicated.\n * @param passive The passive flag of the new duplicated listener.\n * @param once The once flag of the new duplicated listener.\n * @param signal The signal object of the new duplicated listener.\n */\nfunction warnDuplicate(\n    listener: Listener,\n    passive: boolean,\n    once: boolean,\n    signal: EventTarget.AbortSignal | undefined,\n): void {\n    EventListenerWasDuplicated.warn(\n        isCapture(listener) ? \"capture\" : \"bubble\",\n        listener.callback,\n    )\n\n    if (isPassive(listener) !== passive) {\n        OptionWasIgnored.warn(\"passive\")\n    }\n    if (isOnce(listener) !== once) {\n        OptionWasIgnored.warn(\"once\")\n    }\n    if (listener.signal !== signal) {\n        OptionWasIgnored.warn(\"signal\")\n    }\n}\n\n// Set enumerable\nconst keys = Object.getOwnPropertyNames(EventTarget.prototype)\nfor (let i = 0; i < keys.length; ++i) {\n    if (keys[i] === \"constructor\") {\n        continue\n    }\n    Object.defineProperty(EventTarget.prototype, keys[i], { enumerable: true })\n}\n\n// Ensure `eventTarget instanceof window.EventTarget` is `true`.\nif (\n    typeof Global !== \"undefined\" &&\n    typeof Global.EventTarget !== \"undefined\"\n) {\n    Object.setPrototypeOf(EventTarget.prototype, Global.EventTarget.prototype)\n}\n","import { Event } from \"./event\"\nimport { EventTarget, getEventTargetInternalData } from \"./event-target\"\nimport { addListener, ListenerList, removeListener } from \"./listener-list\"\nimport { ensureListenerList } from \"./listener-list-map\"\nimport { InvalidAttributeHandler } from \"./warnings\"\n\n/**\n * Get the current value of a given event attribute.\n * @param target The `EventTarget` object to get.\n * @param type The event type.\n */\nexport function getEventAttributeValue<\n    TEventTarget extends EventTarget<any, any>,\n    TEvent extends Event\n>(\n    target: TEventTarget,\n    type: string,\n): EventTarget.CallbackFunction<TEventTarget, TEvent> | null {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    return listMap[type]?.attrCallback ?? null\n}\n\n/**\n * Set an event listener to a given event attribute.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nexport function setEventAttributeValue(\n    target: EventTarget<any, any>,\n    type: string,\n    callback: EventTarget.CallbackFunction<any, any> | null,\n): void {\n    if (callback != null && typeof callback !== \"function\") {\n        InvalidAttributeHandler.warn(callback)\n    }\n\n    if (\n        typeof callback === \"function\" ||\n        (typeof callback === \"object\" && callback !== null)\n    ) {\n        upsertEventAttributeListener(target, type, callback)\n    } else {\n        removeEventAttributeListener(target, type)\n    }\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Update or insert the given event attribute handler.\n * @param target The `EventTarget` object to set.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction upsertEventAttributeListener<\n    TEventTarget extends EventTarget<any, any>\n>(\n    target: TEventTarget,\n    type: string,\n    callback: EventTarget.CallbackFunction<TEventTarget, any>,\n): void {\n    const list = ensureListenerList(\n        getEventTargetInternalData(target, \"target\"),\n        String(type),\n    )\n    list.attrCallback = callback\n\n    if (list.attrListener == null) {\n        list.attrListener = addListener(\n            list,\n            defineEventAttributeCallback(list),\n            false,\n            false,\n            false,\n            undefined,\n        )\n    }\n}\n\n/**\n * Remove the given event attribute handler.\n * @param target The `EventTarget` object to remove.\n * @param type The event type.\n * @param callback The event listener.\n */\nfunction removeEventAttributeListener(\n    target: EventTarget<any, any>,\n    type: string,\n): void {\n    const listMap = getEventTargetInternalData(target, \"target\")\n    const list = listMap[String(type)]\n    if (list && list.attrListener) {\n        removeListener(list, list.attrListener.callback, false)\n        list.attrCallback = list.attrListener = undefined\n    }\n}\n\n/**\n * Define the callback function for the given listener list object.\n * It calls `attrCallback` property if the property value is a function.\n * @param list The `ListenerList` object.\n */\nfunction defineEventAttributeCallback(\n    list: ListenerList,\n): EventTarget.CallbackFunction<any, any> {\n    return function (event) {\n        const callback = list.attrCallback\n        if (typeof callback === \"function\") {\n            callback.call(this, event)\n        }\n    }\n}\n","import { Event } from \"./event\"\nimport {\n    getEventAttributeValue,\n    setEventAttributeValue,\n} from \"./event-attribute-handler\"\nimport { EventTarget } from \"./event-target\"\n\n/**\n * Define an `EventTarget` class that has event attibutes.\n * @param types The types to define event attributes.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineCustomEventTarget<\n    TEventMap extends Record<string, Event>,\n    TMode extends \"standard\" | \"strict\" = \"standard\"\n>(\n    ...types: (string & keyof TEventMap)[]\n): defineCustomEventTarget.CustomEventTargetConstructor<TEventMap, TMode> {\n    class CustomEventTarget extends EventTarget {}\n    for (let i = 0; i < types.length; ++i) {\n        defineEventAttribute(CustomEventTarget.prototype, types[i])\n    }\n\n    return CustomEventTarget as any\n}\n\nexport namespace defineCustomEventTarget {\n    /**\n     * The interface of CustomEventTarget constructor.\n     */\n    export type CustomEventTargetConstructor<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = {\n        /**\n         * Create a new instance.\n         */\n        new (): CustomEventTarget<TEventMap, TMode>\n        /**\n         * prototype object.\n         */\n        prototype: CustomEventTarget<TEventMap, TMode>\n    }\n\n    /**\n     * The interface of CustomEventTarget.\n     */\n    export type CustomEventTarget<\n        TEventMap extends Record<string, Event>,\n        TMode extends \"standard\" | \"strict\"\n    > = EventTarget<TEventMap, TMode> &\n        defineEventAttribute.EventAttributes<any, TEventMap>\n}\n\n/**\n * Define an event attribute.\n * @param target The `EventTarget` object to define an event attribute.\n * @param type The event type to define.\n * @param _eventClass Unused, but to infer `Event` class type.\n * @deprecated Use `getEventAttributeValue`/`setEventAttributeValue` pair on your derived class instead because of static analysis friendly.\n */\nexport function defineEventAttribute<\n    TEventTarget extends EventTarget,\n    TEventType extends string,\n    TEventConstrucor extends typeof Event\n>(\n    target: TEventTarget,\n    type: TEventType,\n    _eventClass?: TEventConstrucor,\n): asserts target is TEventTarget &\n    defineEventAttribute.EventAttributes<\n        TEventTarget,\n        Record<TEventType, InstanceType<TEventConstrucor>>\n    > {\n    Object.defineProperty(target, `on${type}`, {\n        get() {\n            return getEventAttributeValue(this, type)\n        },\n        set(value) {\n            setEventAttributeValue(this, type, value)\n        },\n        configurable: true,\n        enumerable: true,\n    })\n}\n\nexport namespace defineEventAttribute {\n    /**\n     * Definition of event attributes.\n     */\n    export type EventAttributes<\n        TEventTarget extends EventTarget<any, any>,\n        TEventMap extends Record<string, Event>\n    > = {\n        [P in string &\n            keyof TEventMap as `on${P}`]: EventTarget.CallbackFunction<\n            TEventTarget,\n            TEventMap[P]\n        > | null\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}