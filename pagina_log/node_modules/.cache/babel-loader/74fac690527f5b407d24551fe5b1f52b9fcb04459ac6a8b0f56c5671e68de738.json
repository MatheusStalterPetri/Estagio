{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport EventTarget from '../../polyfillLoaders/EventTarget.js';\nexport function dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n  constructor(config) {\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    this.totalScrollSize = {\n      width: 0,\n      height: 0\n    };\n    this.offsetWithinScroller = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Flag for debouncing asynchnronous reflow requests.\n     */\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    this._pin = null;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n    this._lastVisible = 0;\n    this._eventTargetPromise = EventTarget().then(Ctor => {\n      this._eventTarget = new Ctor();\n    });\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n    this._items = [];\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n    this._overhang = 1000;\n    this._eventTarget = null;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(() => this.config = config || this._defaultConfig);\n  }\n  get _defaultConfig() {\n    return {\n      direction: 'vertical'\n    };\n  }\n  set config(config) {\n    Object.assign(this, Object.assign({}, this._defaultConfig, config));\n  }\n  get config() {\n    return {\n      direction: this.direction\n    };\n  }\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items() {\n    return this._items;\n  }\n  set items(items) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n  /**\n   * Primary scrolling direction.\n   */\n  get direction() {\n    return this._direction;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize() {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {\n      _viewDim1,\n      _viewDim2\n    } = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll() {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._updateVisibleIndices({\n        emit: true\n      });\n    }\n    this._checkThresholds();\n  }\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n  set pin(options) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n  get pin() {\n    if (this._pin !== null) {\n      const {\n        index,\n        block\n      } = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block\n      };\n    }\n    return null;\n  }\n  _clampScrollPosition(val) {\n    return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n  }\n  unpin() {\n    if (this._pin !== null) {\n      this._emitUnpinned();\n      this._pin = null;\n    }\n  }\n  async dispatchEvent(evt) {\n    await this._eventTargetPromise;\n    this._eventTarget.dispatchEvent(evt);\n  }\n  async addEventListener(type, listener, options) {\n    await this._eventTargetPromise;\n    this._eventTarget.addEventListener(type, listener, options);\n  }\n  async removeEventListener(type, callback, options) {\n    await this._eventTargetPromise;\n    this._eventTarget.removeEventListener(type, callback, options);\n  }\n  _updateLayout() {\n    // Override\n  }\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  get _viewDim1() {\n    return this._viewportSize[this._sizeDim];\n  }\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  get _viewDim2() {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n  _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n  _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n  _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._emitScrollSize();\n    this._emitRange();\n    this._emitChildPositions();\n    this._emitScrollError();\n  }\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {\n        index,\n        block\n      } = this.pin;\n      this._scrollPosition = this._calculateScrollIntoViewPosition({\n        index,\n        block: block || 'start'\n      }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  _calculateScrollIntoViewPosition(options) {\n    const {\n      block\n    } = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition = itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition = Math.abs(currentScrollPosition - itemStartPosition) < Math.abs(currentScrollPosition - itemEndPosition) ? itemStartPosition : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n  getScrollIntoViewCoordinates(options) {\n    return {\n      [this._positionDim]: this._calculateScrollIntoViewPosition(options)\n    };\n  }\n  _emitUnpinned() {\n    this.dispatchEvent(new CustomEvent('unpinned'));\n  }\n  _emitRange() {\n    const detail = {\n      first: this._first,\n      last: this._last,\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible\n    };\n    this.dispatchEvent(new CustomEvent('rangechange', {\n      detail\n    }));\n  }\n  _emitScrollSize() {\n    const detail = {\n      [this._sizeDim]: this._scrollSize,\n      [this._secondarySizeDim]: null\n    };\n    this.dispatchEvent(new CustomEvent('scrollsizechange', {\n      detail\n    }));\n  }\n  _emitScrollError() {\n    if (this._scrollError) {\n      const detail = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0\n      };\n      this.dispatchEvent(new CustomEvent('scrollerrorchange', {\n        detail\n      }));\n      this._scrollError = 0;\n    }\n  }\n  /**\n   * Get or estimate the top and left positions of items in the current range.\n   * Emit an itempositionchange event with these positions.\n   */\n  _emitChildPositions() {\n    if (this._first !== -1 && this._last !== -1) {\n      const detail = new Map();\n      for (let idx = this._first; idx <= this._last; idx++) {\n        detail.set(idx, this._getItemPosition(idx));\n      }\n      this.dispatchEvent(new CustomEvent('itempositionchange', {\n        detail\n      }));\n    }\n  }\n  /**\n   * Number of items to display.\n   */\n  get _num() {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n  _checkThresholds() {\n    if (this._viewDim1 === 0 && this._num > 0 || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      }\n    }\n  }\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  _updateVisibleIndices(options) {\n    if (this._first === -1 || this._last === -1) return;\n    let firstVisible = this._first;\n    while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n      firstVisible++;\n    }\n    let lastVisible = this._last;\n    while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n      lastVisible--;\n    }\n    if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._emitRange();\n      }\n    }\n  }\n}","map":{"version":3,"names":["EventTarget","dim1","direction","dim2","pos1","pos2","BaseLayout","constructor","config","_latestCoords","left","top","_direction","_viewportSize","width","height","totalScrollSize","offsetWithinScroller","_pendingReflow","_pendingLayoutUpdate","_pin","_firstVisible","_lastVisible","_eventTargetPromise","then","Ctor","_eventTarget","_physicalMin","_physicalMax","_first","_last","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_scrollPosition","_scrollError","_items","_scrollSize","_overhang","Promise","resolve","_defaultConfig","Object","assign","items","_scheduleReflow","dir","_triggerReflow","viewportSize","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","coords","oldPos","change","Math","abs","_updateVisibleIndices","emit","reflowIfNeeded","force","_reflow","pin","options","index","block","max","min","length","_clampScrollPosition","val","unpin","_emitUnpinned","dispatchEvent","evt","addEventListener","type","listener","removeEventListener","callback","_updateLayout","_updateScrollSize","_setPositionFromPin","_getActiveItems","_emitScrollSize","_emitRange","_emitChildPositions","_emitScrollError","lastScrollPosition","_calculateScrollIntoViewPosition","itemStartPosition","_getItemPosition","scrollPosition","itemSize","_getItemSize","itemEndPosition","currentScrollPosition","getScrollIntoViewCoordinates","CustomEvent","detail","first","last","firstVisible","lastVisible","Map","idx","set","_num","round"],"sources":["../../src/layouts/shared/BaseLayout.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport EventTarget from '../../polyfillLoaders/EventTarget.js';\nimport {\n  Layout,\n  ChildPositions,\n  Positions,\n  ScrollDirection,\n  Size,\n  dimension,\n  position,\n  InternalRange,\n  PinOptions,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n} from './Layout.js';\n\ntype UpdateVisibleIndicesOptions = {\n  emit?: boolean;\n};\n\nexport function dim1(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\n\nexport function dim2(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\n\nexport function pos1(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\n\nexport function pos2(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\n\nexport abstract class BaseLayout<C extends BaseLayoutConfig> implements Layout {\n  /**\n   * The last set viewport scroll position.\n   */\n  private _latestCoords: Positions = {left: 0, top: 0};\n\n  /**\n   * Scrolling direction.\n   */\n  private _direction: ScrollDirection | null = null;\n\n  /**\n   * Dimensions of the viewport.\n   */\n  private _viewportSize: Size = {width: 0, height: 0};\n\n  public totalScrollSize: Size = {width: 0, height: 0};\n\n  public offsetWithinScroller: Positions = {left: 0, top: 0};\n\n  /**\n   * Flag for debouncing asynchnronous reflow requests.\n   */\n  private _pendingReflow = false;\n\n  private _pendingLayoutUpdate = false;\n\n  protected _pin: PinOptions | null = null;\n\n  /**\n   * The index of the first item intersecting the viewport.\n   */\n  protected _firstVisible = 0;\n\n  /**\n   * The index of the last item intersecting the viewport.\n   */\n  protected _lastVisible = 0;\n\n  private _eventTargetPromise: Promise<void> = EventTarget().then((Ctor) => {\n    this._eventTarget = new Ctor();\n  });\n\n  /**\n   * Pixel offset in the scroll direction of the first child.\n   */\n  protected _physicalMin = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the last child.\n   */\n  protected _physicalMax = 0;\n\n  /**\n   * Index of the first child.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child.\n   */\n  protected _last = -1;\n\n  /**\n   * Length in the scrolling direction.\n   */\n  protected _sizeDim: dimension = 'height';\n\n  /**\n   * Length in the non-scrolling direction.\n   */\n  protected _secondarySizeDim: dimension = 'width';\n\n  /**\n   * Position in the scrolling direction.\n   */\n  protected _positionDim: position = 'top';\n\n  /**\n   * Position in the non-scrolling direction.\n   */\n  protected _secondaryPositionDim: position = 'left';\n\n  /**\n   * Current scroll offset in pixels.\n   */\n  protected _scrollPosition = 0;\n\n  /**\n   * Difference between current scroll offset and scroll offset calculated due\n   * to a reflow.\n   */\n  protected _scrollError = 0;\n\n  /**\n   * Total number of items that could possibly be displayed. Used to help\n   * calculate the scroll size.\n   */\n  protected _items: unknown[] = [];\n\n  /**\n   * The total (estimated) length of all items in the scrolling direction.\n   */\n  protected _scrollSize = 1;\n\n  /**\n   * Number of pixels beyond the viewport to still include\n   * in the active range of items.\n   */\n  // TODO (graynorton): Probably want to make this something we calculate based\n  // on viewport size, item size, other factors, possibly still with a dial of some kind\n  protected _overhang = 1000;\n\n  private _eventTarget: EventTarget | null = null;\n\n  protected get _defaultConfig(): C {\n    return {\n      direction: 'vertical',\n    } as C;\n  }\n\n  constructor(config?: C) {\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(() => (this.config = config || this._defaultConfig));\n  }\n\n  set config(config: C) {\n    Object.assign(this, Object.assign({}, this._defaultConfig, config));\n  }\n\n  get config(): C {\n    return {\n      direction: this.direction,\n    } as C;\n  }\n\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items(): unknown[] {\n    return this._items;\n  }\n  set items(items: unknown[]) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n\n  /**\n   * Primary scrolling direction.\n   */\n  get direction(): ScrollDirection {\n    return this._direction!;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize(): Size {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {_viewDim1, _viewDim2} = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll(): Positions {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._updateVisibleIndices({emit: true});\n    }\n    this._checkThresholds();\n  }\n\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n\n  set pin(options: PinOptions | null) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n\n  get pin() {\n    if (this._pin !== null) {\n      const {index, block} = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block,\n      };\n    }\n    return null;\n  }\n\n  _clampScrollPosition(val: number) {\n    return Math.max(\n      -this.offsetWithinScroller[this._positionDim],\n      Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1)\n    );\n  }\n\n  unpin() {\n    if (this._pin !== null) {\n      this._emitUnpinned();\n      this._pin = null;\n    }\n  }\n\n  async dispatchEvent(evt: Event) {\n    await this._eventTargetPromise;\n    this._eventTarget!.dispatchEvent(evt);\n  }\n\n  async addEventListener(\n    type: string,\n    listener: EventListener | EventListenerObject | null,\n    options?: boolean | AddEventListenerOptions | undefined\n  ) {\n    await this._eventTargetPromise;\n    this._eventTarget!.addEventListener(type, listener, options);\n  }\n\n  async removeEventListener(\n    type: string,\n    callback: EventListener | EventListenerObject | null,\n    options?: boolean | EventListenerOptions | undefined\n  ) {\n    await this._eventTargetPromise;\n    this._eventTarget!.removeEventListener(type, callback, options);\n  }\n\n  /**\n   * Get the top and left positioning of the item at idx.\n   */\n  protected abstract _getItemPosition(idx: number): Positions;\n\n  /**\n   * Update _first and _last based on items that should be in the current\n   * range.\n   */\n  protected abstract _getActiveItems(): void;\n\n  protected abstract _getItemSize(_idx: number): Size;\n\n  /**\n   * Calculates (precisely or by estimating, if needed) the total length of all items in\n   * the scrolling direction, including spacing, caching the value in the `_scrollSize` field.\n   *\n   * Should return a minimum value of 1 to ensure at least one item is rendered.\n   * TODO (graynorton): Possibly no longer required, but leaving here until it can be verified.\n   */\n  protected abstract _updateScrollSize(): void;\n\n  protected _updateLayout(): void {\n    // Override\n  }\n\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  protected get _viewDim1(): number {\n    return this._viewportSize[this._sizeDim];\n  }\n\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  protected get _viewDim2(): number {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  protected _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  protected _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  protected _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n\n  protected _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._emitScrollSize();\n    this._emitRange();\n    this._emitChildPositions();\n    this._emitScrollError();\n  }\n\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  protected _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {index, block} = this.pin;\n      this._scrollPosition =\n        this._calculateScrollIntoViewPosition({\n          index,\n          block: block || 'start',\n        }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  protected _calculateScrollIntoViewPosition(options: PinOptions) {\n    const {block} = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition =\n          itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition =\n            Math.abs(currentScrollPosition - itemStartPosition) <\n            Math.abs(currentScrollPosition - itemEndPosition)\n              ? itemStartPosition\n              : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n\n  public getScrollIntoViewCoordinates(\n    options: PinOptions\n  ): ScrollToCoordinates {\n    return {\n      [this._positionDim as position]:\n        this._calculateScrollIntoViewPosition(options),\n    } as ScrollToOptions;\n  }\n\n  private _emitUnpinned() {\n    this.dispatchEvent(new CustomEvent('unpinned'));\n  }\n\n  protected _emitRange() {\n    const detail: InternalRange = {\n      first: this._first,\n      last: this._last,\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible,\n    };\n    this.dispatchEvent(new CustomEvent('rangechange', {detail}));\n  }\n\n  protected _emitScrollSize() {\n    const detail = {\n      [this._sizeDim]: this._scrollSize,\n      [this._secondarySizeDim]: null,\n    };\n    this.dispatchEvent(new CustomEvent('scrollsizechange', {detail}));\n  }\n\n  protected _emitScrollError() {\n    if (this._scrollError) {\n      const detail = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0,\n      };\n      this.dispatchEvent(new CustomEvent('scrollerrorchange', {detail}));\n      this._scrollError = 0;\n    }\n  }\n\n  /**\n   * Get or estimate the top and left positions of items in the current range.\n   * Emit an itempositionchange event with these positions.\n   */\n  protected _emitChildPositions() {\n    if (this._first !== -1 && this._last !== -1) {\n      const detail: ChildPositions = new Map();\n      for (let idx = this._first; idx <= this._last; idx++) {\n        detail.set(idx, this._getItemPosition(idx));\n      }\n      this.dispatchEvent(new CustomEvent('itempositionchange', {detail}));\n    }\n  }\n\n  /**\n   * Number of items to display.\n   */\n  private get _num(): number {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n\n  private _checkThresholds() {\n    if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(\n        this._scrollSize,\n        this._scrollPosition + this._viewDim1 + this._overhang\n      );\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      }\n    }\n  }\n\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  protected _updateVisibleIndices(options?: UpdateVisibleIndicesOptions) {\n    if (this._first === -1 || this._last === -1) return;\n\n    let firstVisible = this._first;\n    while (\n      firstVisible < this._last &&\n      Math.round(\n        this._getItemPosition(firstVisible)[this._positionDim] +\n          this._getItemSize(firstVisible)[this._sizeDim]\n      ) <= Math.round(this._scrollPosition)\n    ) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n    while (\n      lastVisible > this._first &&\n      Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n        Math.round(this._scrollPosition + this._viewDim1)\n    ) {\n      lastVisible--;\n    }\n\n    if (\n      firstVisible !== this._firstVisible ||\n      lastVisible !== this._lastVisible\n    ) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._emitRange();\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}