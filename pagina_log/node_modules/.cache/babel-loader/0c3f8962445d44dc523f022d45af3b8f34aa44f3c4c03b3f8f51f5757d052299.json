{"ast":null,"code":"export class IgcTreeSelectionService {\n  constructor(tree) {\n    this.itemSelection = new Set();\n    this.indeterminateItems = new Set();\n    this.tree = tree;\n  }\n  selectMultipleItems(item) {\n    if (!this.itemSelection.size) {\n      this.selectItem(item);\n      return;\n    }\n    const lastSelectedItemIndex = this.tree.items.indexOf(this.getSelectedItems()[this.itemSelection.size - 1]);\n    const currentItemIndex = this.tree.items.indexOf(item);\n    const items = this.tree.items.slice(Math.min(currentItemIndex, lastSelectedItemIndex), Math.max(currentItemIndex, lastSelectedItemIndex) + 1);\n    const added = items.filter(_item => !this.isItemSelected(_item));\n    const newSelection = this.getSelectedItems().concat(added);\n    this.emitItemSelectionEvent(newSelection, added, []);\n  }\n  selectItem(item) {\n    if (this.tree.selection === 'none') {\n      return;\n    }\n    this.emitItemSelectionEvent([...this.getSelectedItems(), item], [item], []);\n  }\n  deselectItem(item) {\n    const newSelection = this.getSelectedItems().filter(_item => _item !== item);\n    this.emitItemSelectionEvent(newSelection, [], [item]);\n  }\n  clearItemsSelection() {\n    const oldSelection = this.getSelectedItems();\n    const oldIndeterminate = this.getIndeterminateItems();\n    this.itemSelection.clear();\n    this.indeterminateItems.clear();\n    oldSelection.forEach(i => i.selected = false);\n    oldIndeterminate.forEach(i => i.indeterminate = false);\n  }\n  isItemSelected(item) {\n    return this.itemSelection.has(item);\n  }\n  isItemIndeterminate(item) {\n    return this.indeterminateItems.has(item);\n  }\n  ensureStateOnItemDelete(item) {\n    this.deselectItemsWithNoEvent([item, ...item.getChildren({\n      flatten: true\n    })], true);\n  }\n  retriggerItemState(item) {\n    if (item.selected) {\n      this.itemSelection.delete(item);\n      this.selectItemsWithNoEvent([item]);\n    } else {\n      this.itemSelection.add(item);\n      this.deselectItemsWithNoEvent([item]);\n    }\n  }\n  emitItemSelectionEvent(newSelection, added, removed) {\n    const currSelection = this.getSelectedItems();\n    if (this.areEqualCollections(currSelection, newSelection)) {\n      return;\n    }\n    if (this.tree.selection === 'cascade') {\n      this.emitCascadeItemSelectionEvent(currSelection, added, removed);\n      return;\n    }\n    const args = {\n      detail: {\n        newSelection\n      },\n      cancelable: true\n    };\n    const allowed = this.tree.emitEvent('igcSelection', args);\n    if (!allowed) {\n      return;\n    }\n    if (this.areEqualCollections(newSelection, args.detail.newSelection)) {\n      this.itemSelection = new Set(newSelection);\n      this.updateItemsState(currSelection);\n    }\n  }\n  selectItemsWithNoEvent(items) {\n    const oldSelection = this.getSelectedItems();\n    if (this.tree && this.tree.selection === 'cascade') {\n      this.cascadeSelectItemsWithNoEvent(items, oldSelection);\n      return;\n    }\n    items.forEach(item => this.itemSelection.add(item));\n    this.updateItemsState(oldSelection);\n  }\n  deselectItemsWithNoEvent(items, onDelete = false) {\n    if (this.tree && this.tree.selection === 'cascade') {\n      this.cascadeDeselectItemsWithNoEvent(items, onDelete);\n      return;\n    }\n    const itemSet = new Set(items);\n    const oldSelection = onDelete ? this.getSelectedItems().filter(i => !itemSet.has(i)) : this.getSelectedItems();\n    if (!items) {\n      this.itemSelection.clear();\n    } else {\n      items.forEach(item => this.itemSelection.delete(item));\n    }\n    this.updateItemsState(oldSelection);\n  }\n  emitCascadeItemSelectionEvent(currSelection, added, removed) {\n    const oldIndeterminate = this.getIndeterminateItems();\n    this.calculateItemsNewSelectionState(currSelection, added, removed);\n    const args = {\n      detail: {\n        newSelection: Array.from(this.itemsToBeSelected)\n      },\n      cancelable: true\n    };\n    const allowed = this.tree.emitEvent('igcSelection', args);\n    if (!allowed) {\n      return;\n    }\n    if (this.areEqualCollections(Array.from(this.itemsToBeSelected), args.detail.newSelection)) {\n      this.itemSelection = new Set(this.itemsToBeSelected);\n      this.indeterminateItems = new Set(this.itemsToBeIndeterminate);\n      this.updateItemsState(currSelection, oldIndeterminate);\n    }\n  }\n  cascadeSelectItemsWithNoEvent(items, oldSelection) {\n    const oldIndeterminate = this.getIndeterminateItems();\n    const newSelection = [...oldSelection, ...items];\n    const newSelectionSet = new Set(newSelection);\n    const removed = oldSelection.filter(x => !newSelectionSet.has(x));\n    const added = newSelection.filter(x => !this.itemSelection.has(x));\n    this.calculateItemsNewSelectionState(oldSelection, added, removed);\n    this.itemSelection = new Set(this.itemsToBeSelected);\n    this.indeterminateItems = new Set(this.itemsToBeIndeterminate);\n    this.updateItemsState(oldSelection, oldIndeterminate);\n  }\n  cascadeDeselectItemsWithNoEvent(items, onDelete = false) {\n    const itemSet = new Set(items);\n    const oldSelection = onDelete ? this.getSelectedItems().filter(i => !itemSet.has(i)) : this.getSelectedItems();\n    const oldIndeterminate = onDelete ? this.getIndeterminateItems().filter(i => !itemSet.has(i)) : this.getIndeterminateItems();\n    if (!items) {\n      this.itemSelection.clear();\n      this.indeterminateItems.clear();\n    } else {\n      this.calculateItemsNewSelectionState(oldSelection, [], items);\n      this.itemSelection = new Set(this.itemsToBeSelected);\n      this.indeterminateItems = new Set(this.itemsToBeIndeterminate);\n    }\n    this.updateItemsState(oldSelection, oldIndeterminate);\n  }\n  calculateItemsNewSelectionState(oldSelection, added, removed) {\n    this.itemsToBeSelected = new Set(oldSelection);\n    this.itemsToBeIndeterminate = new Set(this.getIndeterminateItems());\n    this.cascadeSelectionState(removed, false);\n    this.cascadeSelectionState(added, true);\n  }\n  cascadeSelectionState(items, selected) {\n    if (!items || items.length === 0) {\n      return;\n    }\n    const parents = new Set();\n    items.forEach(item => {\n      this.selectDeselectItem(item, selected);\n      const itemAndAllChildren = item.getChildren({\n        flatten: true\n      }) || [];\n      itemAndAllChildren.forEach(i => {\n        this.selectDeselectItem(i, selected);\n      });\n      if (item && item.parent) {\n        parents.add(item.parent);\n      }\n    });\n    for (const parent of parents) {\n      this.handleParentSelectionState(parent);\n    }\n  }\n  handleParentSelectionState(item) {\n    if (!item) {\n      return;\n    }\n    this.handleItemSelectionState(item);\n    if (item.parent) {\n      this.handleParentSelectionState(item.parent);\n    }\n  }\n  handleItemSelectionState(item) {\n    const itemsArray = item && item.getChildren() ? item.getChildren() : [];\n    if (itemsArray.length) {\n      if (itemsArray.every(i => this.itemsToBeSelected.has(i))) {\n        this.selectDeselectItem(item, true);\n      } else if (itemsArray.some(i => this.itemsToBeSelected.has(i) || this.itemsToBeIndeterminate.has(i))) {\n        this.selectDeselectItem(item, false, true);\n      } else {\n        this.selectDeselectItem(item, false);\n      }\n    } else {\n      if (this.isItemSelected(item)) {\n        this.selectDeselectItem(item, true);\n      } else {\n        this.selectDeselectItem(item, false);\n      }\n    }\n  }\n  updateItemsState(oldSelection, oldIndeterminate = []) {\n    const selected = new Set(oldSelection);\n    const indeterminated = new Set(oldIndeterminate);\n    this.getSelectedItems().forEach(i => {\n      if (!selected.has(i)) {\n        i.selected = true;\n      }\n    });\n    oldSelection.forEach(i => {\n      if (!this.itemSelection.has(i)) {\n        i.selected = false;\n      }\n    });\n    if (this.tree.selection === 'cascade') {\n      this.indeterminateItems.forEach(i => {\n        if (!indeterminated.has(i)) {\n          i.indeterminate = true;\n        }\n      });\n      oldIndeterminate.forEach(i => {\n        if (!this.indeterminateItems.has(i)) {\n          i.indeterminate = false;\n        }\n      });\n    }\n  }\n  getSelectedItems() {\n    return this.itemSelection.size ? Array.from(this.itemSelection) : [];\n  }\n  getIndeterminateItems() {\n    return this.indeterminateItems.size ? Array.from(this.indeterminateItems) : [];\n  }\n  areEqualCollections(first, second) {\n    return first.length === second.length && new Set(first.concat(second)).size === first.length;\n  }\n  selectDeselectItem(item, select, indeterminate = false) {\n    if (indeterminate) {\n      this.itemsToBeIndeterminate.add(item);\n      this.itemsToBeSelected.delete(item);\n      return;\n    }\n    if (select) {\n      this.itemsToBeSelected.add(item);\n      this.itemsToBeIndeterminate.delete(item);\n    } else {\n      this.itemsToBeSelected.delete(item);\n      this.itemsToBeIndeterminate.delete(item);\n    }\n  }\n}","map":{"version":3,"names":["IgcTreeSelectionService","constructor","tree","itemSelection","Set","indeterminateItems","selectMultipleItems","item","size","selectItem","lastSelectedItemIndex","items","indexOf","getSelectedItems","currentItemIndex","slice","Math","min","max","added","filter","_item","isItemSelected","newSelection","concat","emitItemSelectionEvent","selection","deselectItem","clearItemsSelection","oldSelection","oldIndeterminate","getIndeterminateItems","clear","forEach","i","selected","indeterminate","has","isItemIndeterminate","ensureStateOnItemDelete","deselectItemsWithNoEvent","getChildren","flatten","retriggerItemState","delete","selectItemsWithNoEvent","add","removed","currSelection","areEqualCollections","emitCascadeItemSelectionEvent","args","detail","cancelable","allowed","emitEvent","updateItemsState","cascadeSelectItemsWithNoEvent","onDelete","cascadeDeselectItemsWithNoEvent","itemSet","calculateItemsNewSelectionState","Array","from","itemsToBeSelected","itemsToBeIndeterminate","newSelectionSet","x","cascadeSelectionState","length","parents","selectDeselectItem","itemAndAllChildren","parent","handleParentSelectionState","handleItemSelectionState","itemsArray","every","some","indeterminated","first","second","select"],"sources":["../../../src/components/tree/tree.selection.ts"],"sourcesContent":["import IgcTreeComponent from './tree.js';\nimport IgcTreeItemComponent from './tree-item.js';\nimport { IgcSelectionEventArgs } from './tree.common.js';\n\nexport class IgcTreeSelectionService {\n  private tree!: IgcTreeComponent;\n  private itemSelection: Set<IgcTreeItemComponent> =\n    new Set<IgcTreeItemComponent>();\n  private indeterminateItems: Set<IgcTreeItemComponent> =\n    new Set<IgcTreeItemComponent>();\n  private itemsToBeSelected!: Set<IgcTreeItemComponent>;\n  private itemsToBeIndeterminate!: Set<IgcTreeItemComponent>;\n\n  constructor(tree: IgcTreeComponent) {\n    this.tree = tree;\n  }\n\n  /** Select range from last selected item to the current specified item. */\n  public selectMultipleItems(item: IgcTreeItemComponent): void {\n    if (!this.itemSelection.size) {\n      this.selectItem(item);\n      return;\n    }\n    const lastSelectedItemIndex = this.tree.items.indexOf(\n      this.getSelectedItems()[this.itemSelection.size - 1]\n    );\n    const currentItemIndex = this.tree.items.indexOf(item);\n    const items = this.tree.items.slice(\n      Math.min(currentItemIndex, lastSelectedItemIndex),\n      Math.max(currentItemIndex, lastSelectedItemIndex) + 1\n    );\n\n    const added = items.filter(\n      (_item: IgcTreeItemComponent) => !this.isItemSelected(_item)\n    );\n    const newSelection = this.getSelectedItems().concat(added);\n    this.emitItemSelectionEvent(newSelection, added, []);\n  }\n\n  /** Select the specified item and emit event. */\n  public selectItem(item: IgcTreeItemComponent): void {\n    if (this.tree.selection === 'none') {\n      return;\n    }\n    this.emitItemSelectionEvent([...this.getSelectedItems(), item], [item], []);\n  }\n\n  /** Deselect the specified item and emit event. */\n  public deselectItem(item: IgcTreeItemComponent): void {\n    const newSelection = this.getSelectedItems().filter(\n      (_item: IgcTreeItemComponent) => _item !== item\n    );\n    this.emitItemSelectionEvent(newSelection, [], [item]);\n  }\n\n  /** Clears item selection */\n  public clearItemsSelection(): void {\n    const oldSelection = this.getSelectedItems();\n    const oldIndeterminate = this.getIndeterminateItems();\n    this.itemSelection.clear();\n    this.indeterminateItems.clear();\n    oldSelection.forEach((i: IgcTreeItemComponent) => (i.selected = false));\n    oldIndeterminate.forEach(\n      (i: IgcTreeItemComponent) => (i.indeterminate = false)\n    );\n  }\n\n  public isItemSelected(item: IgcTreeItemComponent): boolean {\n    return this.itemSelection.has(item);\n  }\n\n  public isItemIndeterminate(item: IgcTreeItemComponent): boolean {\n    return this.indeterminateItems.has(item);\n  }\n\n  /** Called on item`s disconnectedCallback */\n  public ensureStateOnItemDelete(item: IgcTreeItemComponent): void {\n    // Don't update the internal state of the deleted items because when moving they should keep it\n    // However update the state of their parents\n    this.deselectItemsWithNoEvent(\n      [item, ...item.getChildren({ flatten: true })],\n      true\n    );\n  }\n\n  /** Retrigger the selection state of the item. */\n  public retriggerItemState(item: IgcTreeItemComponent): void {\n    if (item.selected) {\n      this.itemSelection.delete(item);\n      this.selectItemsWithNoEvent([item]);\n    } else {\n      this.itemSelection.add(item);\n      this.deselectItemsWithNoEvent([item]);\n    }\n  }\n\n  private emitItemSelectionEvent(\n    newSelection: IgcTreeItemComponent[],\n    added: IgcTreeItemComponent[],\n    removed: IgcTreeItemComponent[]\n  ): void {\n    const currSelection = this.getSelectedItems();\n    if (this.areEqualCollections(currSelection, newSelection)) {\n      return;\n    }\n\n    if (this.tree.selection === 'cascade') {\n      this.emitCascadeItemSelectionEvent(currSelection, added, removed);\n      return;\n    }\n\n    const args: IgcSelectionEventArgs = {\n      detail: {\n        newSelection,\n      },\n      cancelable: true,\n    };\n\n    const allowed = this.tree.emitEvent('igcSelection', args);\n    if (!allowed) {\n      return;\n    }\n\n    // if newSelection is overwritten do not proceed (Blazor)\n    if (this.areEqualCollections(newSelection, args.detail.newSelection)) {\n      this.itemSelection = new Set(newSelection);\n      this.updateItemsState(currSelection);\n    }\n  }\n\n  /** Select specified items. No event is emitted. */\n  public selectItemsWithNoEvent(items: IgcTreeItemComponent[]): void {\n    const oldSelection = this.getSelectedItems();\n\n    if (this.tree && this.tree.selection === 'cascade') {\n      this.cascadeSelectItemsWithNoEvent(items, oldSelection);\n      return;\n    }\n\n    items.forEach((item: IgcTreeItemComponent) => this.itemSelection.add(item));\n\n    this.updateItemsState(oldSelection);\n  }\n\n  /** Deselect specified items. No event is emitted. */\n  public deselectItemsWithNoEvent(\n    items?: IgcTreeItemComponent[],\n    onDelete = false\n  ): void {\n    if (this.tree && this.tree.selection === 'cascade') {\n      this.cascadeDeselectItemsWithNoEvent(items, onDelete);\n      return;\n    }\n    const itemSet = new Set(items);\n    const oldSelection = onDelete\n      ? this.getSelectedItems().filter(\n          (i: IgcTreeItemComponent) => !itemSet!.has(i)\n        )\n      : this.getSelectedItems();\n\n    if (!items) {\n      this.itemSelection.clear();\n    } else {\n      items.forEach((item: IgcTreeItemComponent) =>\n        this.itemSelection.delete(item)\n      );\n    }\n\n    this.updateItemsState(oldSelection);\n  }\n\n  private emitCascadeItemSelectionEvent(\n    currSelection: IgcTreeItemComponent[],\n    added: IgcTreeItemComponent[],\n    removed: IgcTreeItemComponent[]\n  ): void {\n    const oldIndeterminate = this.getIndeterminateItems();\n\n    this.calculateItemsNewSelectionState(currSelection, added, removed);\n\n    const args: IgcSelectionEventArgs = {\n      detail: {\n        newSelection: Array.from(this.itemsToBeSelected),\n      },\n      cancelable: true,\n    };\n\n    const allowed = this.tree.emitEvent('igcSelection', args);\n\n    if (!allowed) {\n      return;\n    }\n\n    // if newSelection is overwritten do not proceed (Blazor)\n    if (\n      this.areEqualCollections(\n        Array.from(this.itemsToBeSelected),\n        args.detail.newSelection\n      )\n    ) {\n      this.itemSelection = new Set<IgcTreeItemComponent>(\n        this.itemsToBeSelected\n      );\n      this.indeterminateItems = new Set(this.itemsToBeIndeterminate);\n      this.updateItemsState(currSelection, oldIndeterminate);\n    }\n  }\n\n  private cascadeSelectItemsWithNoEvent(\n    items: IgcTreeItemComponent[],\n    oldSelection: IgcTreeItemComponent[]\n  ): void {\n    const oldIndeterminate = this.getIndeterminateItems();\n\n    const newSelection = [...oldSelection, ...items];\n\n    // retrieve only the rows without their parents/children which has to be added to the selection\n    const newSelectionSet = new Set(newSelection);\n    const removed = oldSelection!.filter((x) => !newSelectionSet.has(x));\n    const added = newSelection!.filter((x) => !this.itemSelection.has(x));\n\n    this.calculateItemsNewSelectionState(oldSelection, added, removed);\n\n    this.itemSelection = new Set(this.itemsToBeSelected);\n    this.indeterminateItems = new Set(this.itemsToBeIndeterminate);\n\n    this.updateItemsState(oldSelection, oldIndeterminate);\n  }\n\n  private cascadeDeselectItemsWithNoEvent(\n    items?: IgcTreeItemComponent[],\n    onDelete = false\n  ): void {\n    const itemSet = new Set(items);\n    const oldSelection = onDelete\n      ? this.getSelectedItems().filter(\n          (i: IgcTreeItemComponent) => !itemSet!.has(i)\n        )\n      : this.getSelectedItems();\n    const oldIndeterminate = onDelete\n      ? this.getIndeterminateItems().filter(\n          (i: IgcTreeItemComponent) => !itemSet!.has(i)\n        )\n      : this.getIndeterminateItems();\n\n    if (!items) {\n      this.itemSelection.clear();\n      this.indeterminateItems.clear();\n    } else {\n      this.calculateItemsNewSelectionState(oldSelection, [], items);\n\n      this.itemSelection = new Set<IgcTreeItemComponent>(\n        this.itemsToBeSelected\n      );\n      this.indeterminateItems = new Set<IgcTreeItemComponent>(\n        this.itemsToBeIndeterminate\n      );\n    }\n\n    this.updateItemsState(oldSelection, oldIndeterminate);\n  }\n\n  // OK (disabled children?)\n  /**\n   * populates the itemsToBeSelected and itemsToBeIndeterminate sets\n   * with the items which will be eventually in selected/indeterminate state\n   */\n  private calculateItemsNewSelectionState(\n    oldSelection: IgcTreeItemComponent[],\n    added: IgcTreeItemComponent[],\n    removed: IgcTreeItemComponent[]\n  ): void {\n    this.itemsToBeSelected = new Set<IgcTreeItemComponent>(oldSelection);\n    this.itemsToBeIndeterminate = new Set<IgcTreeItemComponent>(\n      this.getIndeterminateItems()\n    );\n\n    this.cascadeSelectionState(removed, false);\n    this.cascadeSelectionState(added, true);\n  }\n\n  // OK (disabled children?)\n  /** Ensures proper selection state for all predescessors and descendants during a selection event */\n  private cascadeSelectionState(\n    items: IgcTreeItemComponent[] | undefined,\n    selected: boolean\n  ): void {\n    if (!items || items.length === 0) {\n      return;\n    }\n\n    const parents = new Set<IgcTreeItemComponent>();\n    items.forEach((item: IgcTreeItemComponent) => {\n      // select/deselect items passed by event/api\n      this.selectDeselectItem(item, selected);\n\n      // select/deselect all of their children\n      const itemAndAllChildren = item.getChildren({ flatten: true }) || [];\n      itemAndAllChildren.forEach((i: IgcTreeItemComponent) => {\n        this.selectDeselectItem(i, selected);\n      });\n\n      // add their direct parent to the set\n      if (item && item.parent) {\n        parents.add(item.parent);\n      }\n    });\n\n    // handle direct parents from the set\n    for (const parent of parents) {\n      this.handleParentSelectionState(parent);\n    }\n  }\n\n  // OK (disabled children?)\n  /**\n   * recursively handle the selection state of the direct and indirect parents\n   */\n  private handleParentSelectionState(item: IgcTreeItemComponent): void {\n    if (!item) {\n      return;\n    }\n    this.handleItemSelectionState(item);\n    if (item.parent) {\n      this.handleParentSelectionState(item.parent);\n    }\n  }\n\n  // OK (disabled children?)\n  /**\n   * Handle the selection state of a given item based the selection states of its direct children\n   */\n  private handleItemSelectionState(item: IgcTreeItemComponent): void {\n    const itemsArray = item && item.getChildren() ? item.getChildren() : [];\n    if (itemsArray.length) {\n      if (\n        itemsArray.every((i: IgcTreeItemComponent) =>\n          this.itemsToBeSelected.has(i)\n        )\n      ) {\n        this.selectDeselectItem(item, true);\n      } else if (\n        itemsArray.some(\n          (i: IgcTreeItemComponent) =>\n            this.itemsToBeSelected.has(i) || this.itemsToBeIndeterminate.has(i)\n        )\n      ) {\n        this.selectDeselectItem(item, false, true);\n      } else {\n        this.selectDeselectItem(item, false);\n      }\n    } else {\n      // if the children of the item has been deleted and the item was selected do not change its state\n      if (this.isItemSelected(item)) {\n        this.selectDeselectItem(item, true);\n      } else {\n        this.selectDeselectItem(item, false);\n      }\n    }\n  }\n\n  /** Emits the `selectedChange` event for each item affected by the selection */\n  private updateItemsState(\n    oldSelection: IgcTreeItemComponent[],\n    oldIndeterminate: IgcTreeItemComponent[] = []\n  ): void {\n    const selected = new Set<IgcTreeItemComponent>(oldSelection);\n    const indeterminated = new Set<IgcTreeItemComponent>(oldIndeterminate);\n\n    this.getSelectedItems().forEach((i: IgcTreeItemComponent) => {\n      if (!selected.has(i)) {\n        i.selected = true;\n      }\n    });\n\n    oldSelection.forEach((i: IgcTreeItemComponent) => {\n      if (!this.itemSelection.has(i)) {\n        i.selected = false;\n      }\n    });\n\n    if (this.tree.selection === 'cascade') {\n      this.indeterminateItems.forEach((i: IgcTreeItemComponent) => {\n        if (!indeterminated.has(i)) {\n          i.indeterminate = true;\n        }\n      });\n\n      oldIndeterminate.forEach((i: IgcTreeItemComponent) => {\n        if (!this.indeterminateItems.has(i)) {\n          i.indeterminate = false;\n        }\n      });\n    }\n  }\n\n  /** Returns array of the selected items. */\n  private getSelectedItems(): IgcTreeItemComponent[] {\n    return this.itemSelection.size ? Array.from(this.itemSelection) : [];\n  }\n\n  /** Returns array of the items in indeterminate state. */\n  private getIndeterminateItems(): IgcTreeItemComponent[] {\n    return this.indeterminateItems.size\n      ? Array.from(this.indeterminateItems)\n      : [];\n  }\n\n  private areEqualCollections(\n    first: IgcTreeItemComponent[],\n    second: IgcTreeItemComponent[]\n  ): boolean {\n    return (\n      first.length === second.length &&\n      new Set(first.concat(second)).size === first.length\n    );\n  }\n\n  private selectDeselectItem(\n    item: IgcTreeItemComponent,\n    select: boolean,\n    indeterminate = false\n  ): void {\n    if (indeterminate) {\n      this.itemsToBeIndeterminate.add(item);\n      this.itemsToBeSelected.delete(item);\n      return;\n    }\n\n    if (select) {\n      this.itemsToBeSelected.add(item);\n      this.itemsToBeIndeterminate.delete(item);\n    } else {\n      this.itemsToBeSelected.delete(item);\n      this.itemsToBeIndeterminate.delete(item);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}