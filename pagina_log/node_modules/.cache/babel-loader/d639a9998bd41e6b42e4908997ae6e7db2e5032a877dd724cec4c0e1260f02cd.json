{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { ContextRequestEvent } from './context-request-event.js';\n/**\n * A ContextRoot can be used to gather unsatisfied context requests and redispatch these\n * requests when new providers which satisfy matching context keys are available.\n */\nexport class ContextRoot {\n  constructor() {\n    this.pendingContextRequests = new Map();\n    this.onContextProvider = ev => {\n      const pendingRequests = this.pendingContextRequests.get(ev.context);\n      if (!pendingRequests) {\n        return; // no pending requests for this provider at this time\n      }\n      // clear our list, any still unsatisfied requests will re-add themselves\n      this.pendingContextRequests.delete(ev.context);\n      // loop over all pending requests and re-dispatch them from their source\n      pendingRequests.forEach(request => {\n        const element = request.element;\n        const callback = request.callback;\n        // redispatch if we still have all the parts of the request\n        if (element) {\n          element.dispatchEvent(new ContextRequestEvent(ev.context, callback, true));\n        }\n      });\n    };\n    this.onContextRequest = ev => {\n      // events that are not subscribing should not be captured\n      if (!ev.subscribe) {\n        return;\n      }\n      // store a weakref to this element under the context key\n      const request = {\n        element: ev.target,\n        callback: ev.callback\n      };\n      let pendingContextRequests = this.pendingContextRequests.get(ev.context);\n      if (!pendingContextRequests) {\n        pendingContextRequests = new Set();\n        this.pendingContextRequests.set(ev.context, pendingContextRequests);\n      }\n      // NOTE: if the element is connected multiple times it will add itself\n      // to this set multiple times since the set identify of the request\n      // object will be unique each time.\n      pendingContextRequests.add(request);\n    };\n  }\n  /**\n   * Attach the ContextRoot to a given element to intercept `context-request` and\n   * `context-provider` events.\n   *\n   * @param element an element to add event listeners to\n   */\n  attach(element) {\n    element.addEventListener('context-request', this.onContextRequest);\n    element.addEventListener('context-provider', this.onContextProvider);\n  }\n  /**\n   * Removes the ContextRoot event listeners from a given element.\n   *\n   * @param element an element from which to remove event listeners\n   */\n  detach(element) {\n    element.removeEventListener('context-request', this.onContextRequest);\n    element.removeEventListener('context-provider', this.onContextProvider);\n  }\n}","map":{"version":3,"names":["ContextRequestEvent","ContextRoot","constructor","pendingContextRequests","Map","onContextProvider","ev","pendingRequests","get","context","delete","forEach","request","element","callback","dispatchEvent","onContextRequest","subscribe","target","Set","set","add","attach","addEventListener","detach","removeEventListener"],"sources":["../../src/lib/context-root.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Context} from './create-context.js';\nimport {ContextRequest, ContextRequestEvent} from './context-request-event.js';\nimport {ContextProviderEvent} from './controllers/context-provider.js';\n\ntype UnknownContextKey = Context<unknown, unknown>;\n\n/**\n * A context request, with associated source element, with all objects as weak references.\n */\ntype PendingContextRequest = Omit<\n  ContextRequest<UnknownContextKey>,\n  'context' | 'subscribe'\n> & {element: HTMLElement};\n\n/**\n * A ContextRoot can be used to gather unsatisfied context requests and redispatch these\n * requests when new providers which satisfy matching context keys are available.\n */\nexport class ContextRoot {\n  private pendingContextRequests = new Map<\n    UnknownContextKey,\n    Set<PendingContextRequest>\n  >();\n\n  /**\n   * Attach the ContextRoot to a given element to intercept `context-request` and\n   * `context-provider` events.\n   *\n   * @param element an element to add event listeners to\n   */\n  public attach(element: HTMLElement): void {\n    element.addEventListener('context-request', this.onContextRequest);\n    element.addEventListener('context-provider', this.onContextProvider);\n  }\n\n  /**\n   * Removes the ContextRoot event listeners from a given element.\n   *\n   * @param element an element from which to remove event listeners\n   */\n  public detach(element: HTMLElement): void {\n    element.removeEventListener('context-request', this.onContextRequest);\n    element.removeEventListener('context-provider', this.onContextProvider);\n  }\n\n  private onContextProvider = (\n    ev: ContextProviderEvent<Context<unknown, unknown>>\n  ) => {\n    const pendingRequests = this.pendingContextRequests.get(ev.context);\n    if (!pendingRequests) {\n      return; // no pending requests for this provider at this time\n    }\n\n    // clear our list, any still unsatisfied requests will re-add themselves\n    this.pendingContextRequests.delete(ev.context);\n\n    // loop over all pending requests and re-dispatch them from their source\n    pendingRequests.forEach((request) => {\n      const element = request.element;\n      const callback = request.callback;\n      // redispatch if we still have all the parts of the request\n      if (element) {\n        element.dispatchEvent(\n          new ContextRequestEvent(ev.context, callback, true)\n        );\n      }\n    });\n  };\n\n  private onContextRequest = (\n    ev: ContextRequestEvent<Context<unknown, unknown>>\n  ) => {\n    // events that are not subscribing should not be captured\n    if (!ev.subscribe) {\n      return;\n    }\n    // store a weakref to this element under the context key\n    const request: PendingContextRequest = {\n      element: ev.target as HTMLElement,\n      callback: ev.callback,\n    };\n    let pendingContextRequests = this.pendingContextRequests.get(ev.context);\n    if (!pendingContextRequests) {\n      pendingContextRequests = new Set();\n      this.pendingContextRequests.set(ev.context, pendingContextRequests);\n    }\n    // NOTE: if the element is connected multiple times it will add itself\n    // to this set multiple times since the set identify of the request\n    // object will be unique each time.\n    pendingContextRequests.add(request);\n  };\n}\n"],"mappings":"AAAA;;;;;AAOA,SAAwBA,mBAAmB,QAAO,4BAA4B;AAa9E;;;;AAIA,OAAM,MAAOC,WAAW;EAAxBC,YAAA;IACU,KAAAC,sBAAsB,GAAG,IAAIC,GAAG,EAGrC;IAuBK,KAAAC,iBAAiB,GACvBC,EAAmD,IACjD;MACF,MAAMC,eAAe,GAAG,IAAI,CAACJ,sBAAsB,CAACK,GAAG,CAACF,EAAE,CAACG,OAAO,CAAC;MACnE,IAAI,CAACF,eAAe,EAAE;QACpB,OAAO,CAAC;;MAGV;MACA,IAAI,CAACJ,sBAAsB,CAACO,MAAM,CAACJ,EAAE,CAACG,OAAO,CAAC;MAE9C;MACAF,eAAe,CAACI,OAAO,CAAEC,OAAO,IAAI;QAClC,MAAMC,OAAO,GAAGD,OAAO,CAACC,OAAO;QAC/B,MAAMC,QAAQ,GAAGF,OAAO,CAACE,QAAQ;QACjC;QACA,IAAID,OAAO,EAAE;UACXA,OAAO,CAACE,aAAa,CACnB,IAAIf,mBAAmB,CAACM,EAAE,CAACG,OAAO,EAAEK,QAAQ,EAAE,IAAI,CAAC,CACpD;;MAEL,CAAC,CAAC;IACJ,CAAC;IAEO,KAAAE,gBAAgB,GACtBV,EAAkD,IAChD;MACF;MACA,IAAI,CAACA,EAAE,CAACW,SAAS,EAAE;QACjB;;MAEF;MACA,MAAML,OAAO,GAA0B;QACrCC,OAAO,EAAEP,EAAE,CAACY,MAAqB;QACjCJ,QAAQ,EAAER,EAAE,CAACQ;OACd;MACD,IAAIX,sBAAsB,GAAG,IAAI,CAACA,sBAAsB,CAACK,GAAG,CAACF,EAAE,CAACG,OAAO,CAAC;MACxE,IAAI,CAACN,sBAAsB,EAAE;QAC3BA,sBAAsB,GAAG,IAAIgB,GAAG,EAAE;QAClC,IAAI,CAAChB,sBAAsB,CAACiB,GAAG,CAACd,EAAE,CAACG,OAAO,EAAEN,sBAAsB,CAAC;;MAErE;MACA;MACA;MACAA,sBAAsB,CAACkB,GAAG,CAACT,OAAO,CAAC;IACrC,CAAC;EACH;EAnEE;;;;;;EAMOU,MAAMA,CAACT,OAAoB;IAChCA,OAAO,CAACU,gBAAgB,CAAC,iBAAiB,EAAE,IAAI,CAACP,gBAAgB,CAAC;IAClEH,OAAO,CAACU,gBAAgB,CAAC,kBAAkB,EAAE,IAAI,CAAClB,iBAAiB,CAAC;EACtE;EAEA;;;;;EAKOmB,MAAMA,CAACX,OAAoB;IAChCA,OAAO,CAACY,mBAAmB,CAAC,iBAAiB,EAAE,IAAI,CAACT,gBAAgB,CAAC;IACrEH,OAAO,CAACY,mBAAmB,CAAC,kBAAkB,EAAE,IAAI,CAACpB,iBAAiB,CAAC;EACzE"},"metadata":{},"sourceType":"module","externalDependencies":[]}