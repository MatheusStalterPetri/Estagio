{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar IgcTabsComponent_1;\nimport { html, LitElement, nothing } from 'lit';\nimport { eventOptions, property, query, queryAssignedElements, state } from 'lit/decorators.js';\nimport { watch } from '../common/decorators/watch.js';\nimport { blazorAdditionalDependencies } from '../common/decorators/blazorAdditionalDependencies.js';\nimport { themes } from '../../theming/theming-decorator.js';\nimport { styles } from './themes/light/tabs.base.css.js';\nimport { styles as bootstrap } from './themes/light/tabs.bootstrap.css.js';\nimport { styles as fluent } from './themes/light/tabs.fluent.css.js';\nimport { styles as indigo } from './themes/light/tabs.indigo.css.js';\nimport { EventEmitterMixin } from '../common/mixins/event-emitter.js';\nimport { createCounter, getOffset, isLTR } from '../common/util.js';\nimport { getAttributesForTags, getNodesForTags, observerConfig } from './utils.js';\nimport { defineComponents } from '../common/definitions/defineComponents.js';\nimport IgcTabComponent from './tab.js';\nimport IgcTabPanelComponent from './tab-panel.js';\nimport IgcIconButtonComponent from '../button/icon-button.js';\ndefineComponents(IgcTabComponent, IgcTabPanelComponent, IgcIconButtonComponent);\nlet IgcTabsComponent = IgcTabsComponent_1 = class IgcTabsComponent extends EventEmitterMixin(LitElement) {\n  constructor() {\n    super(...arguments);\n    this.showScrollButtons = false;\n    this.disableStartScrollButton = true;\n    this.disableEndScrollButton = false;\n    this.alignment = 'start';\n    this.activation = 'auto';\n    this.handleKeyDown = event => {\n      var _a;\n      const {\n        key\n      } = event;\n      const enabledTabs = this.enabledTabs;\n      const ltr = isLTR(this);\n      let index = enabledTabs.indexOf((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest('igc-tab'));\n      switch (key) {\n        case 'ArrowLeft':\n          index = ltr ? (enabledTabs.length + index - 1) % enabledTabs.length : (index + 1) % enabledTabs.length;\n          break;\n        case 'ArrowRight':\n          index = ltr ? (index + 1) % enabledTabs.length : (enabledTabs.length + index - 1) % enabledTabs.length;\n          break;\n        case 'Home':\n          index = 0;\n          break;\n        case 'End':\n          index = enabledTabs.length - 1;\n          break;\n        case 'Enter':\n        case ' ':\n          this.setSelectedTab(enabledTabs[index]);\n          break;\n        default:\n          return;\n      }\n      enabledTabs[index].focus({\n        preventScroll: true\n      });\n      if (this.activation === 'auto') {\n        this.setSelectedTab(enabledTabs[index]);\n        this.emitEvent('igcChange', {\n          detail: this.activeTab\n        });\n      } else {\n        enabledTabs[index].scrollIntoView({\n          block: 'nearest'\n        });\n      }\n      event.preventDefault();\n    };\n  }\n  get enabledTabs() {\n    return this.tabs.filter(tab => !tab.disabled);\n  }\n  get selected() {\n    var _a, _b;\n    return (_b = (_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.panel) !== null && _b !== void 0 ? _b : '';\n  }\n  alignIndicator() {\n    const styles = {\n      visibility: this.activeTab ? 'visible' : 'hidden',\n      transitionDuration: '0.3s'\n    };\n    if (this.activeTab) {\n      Object.assign(styles, {\n        width: `${this.activeTab.offsetWidth}px`,\n        transform: `translate(${isLTR(this) ? getOffset(this.activeTab, this.wrapper).left : getOffset(this.activeTab, this.wrapper).right}px)`\n      });\n    }\n    Object.assign(this.selectedIndicator.style, styles);\n  }\n  async firstUpdated() {\n    var _a;\n    this.showScrollButtons = this.container.scrollWidth > this.container.clientWidth;\n    await this.updateComplete;\n    this.syncAttributes();\n    this.setupObserver();\n    this.setSelectedTab((_a = this.tabs.filter(tab => tab.selected).at(-1)) !== null && _a !== void 0 ? _a : this.enabledTabs.at(0));\n    this.updateSelectedTab();\n  }\n  disconnectedCallback() {\n    var _a, _b;\n    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    (_b = this.mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n    super.disconnectedCallback();\n  }\n  updateButtonsOnResize() {\n    this.showScrollButtons = false;\n    this.performUpdate();\n    this.showScrollButtons = this.container.scrollWidth > this.container.clientWidth;\n    this.updateScrollButtons();\n  }\n  updateScrollButtons() {\n    const {\n        scrollLeft,\n        offsetWidth\n      } = this.container,\n      {\n        scrollWidth\n      } = this.wrapper;\n    this.disableEndScrollButton = scrollWidth <= Math.abs(scrollLeft) + offsetWidth;\n    this.disableStartScrollButton = scrollLeft === 0;\n  }\n  setupObserver() {\n    this.resizeObserver = new ResizeObserver(() => {\n      this.updateButtonsOnResize();\n      this.alignIndicator();\n    });\n    [this.container, this.wrapper, ...this.tabs].forEach(element => this.resizeObserver.observe(element));\n    this.mutationObserver = new MutationObserver(async (records, observer) => {\n      var _a;\n      observer.disconnect();\n      const attributes = getAttributesForTags(records, 'igc-tab');\n      const changed = getNodesForTags(records, this, 'igc-tab');\n      if (attributes.length > 0) {\n        this.activeTab = attributes.find(tab => tab.selected);\n      }\n      if (changed) {\n        changed.addedNodes.forEach(tab => {\n          this.resizeObserver.observe(tab);\n          if (tab.selected) {\n            this.activeTab = tab;\n          }\n        });\n        changed.removedNodes.forEach(tab => {\n          this.resizeObserver.unobserve(tab);\n          if (tab.selected || this.activeTab === tab) {\n            this.activeTab = undefined;\n          }\n        });\n        this.syncAttributes();\n      }\n      this.updateSelectedTab();\n      (_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.scrollIntoView({\n        block: 'nearest'\n      });\n      this.alignIndicator();\n      await this.updateComplete;\n      observer.observe(this, observerConfig);\n    });\n    this.mutationObserver.observe(this, observerConfig);\n  }\n  updateSelectedTab() {\n    this.tabs.forEach(tab => tab.selected = tab === this.activeTab);\n    this.panels.forEach(panel => {\n      var _a;\n      panel.hidden = panel.id !== ((_a = this.activeTab) === null || _a === void 0 ? void 0 : _a.panel);\n    });\n  }\n  syncAttributes() {\n    const prefix = this.id ? `${this.id}-` : '';\n    this.tabs.forEach((tab, index) => {\n      var _a, _b, _c;\n      if (!tab.panel) {\n        tab.panel = (_b = (_a = this.panels.at(index)) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : `${prefix}tab-${IgcTabsComponent_1.increment()}`;\n      }\n      (_c = this.panels.find(panel => panel.id === tab.panel)) === null || _c === void 0 ? void 0 : _c.setAttribute('aria-labelledby', tab.id);\n    });\n  }\n  setSelectedTab(tab) {\n    if (!tab || tab === this.activeTab) {\n      return;\n    }\n    if (this.activeTab) {\n      this.activeTab.selected = false;\n    }\n    this.activeTab = tab;\n    this.activeTab.selected = true;\n  }\n  scrollByTabOffset(direction) {\n    const {\n      scrollLeft,\n      offsetWidth\n    } = this.container;\n    const LTR = isLTR(this),\n      next = direction === 'end';\n    const pivot = Math.abs(next ? offsetWidth + scrollLeft : scrollLeft);\n    let amount = this.tabs.map(tab => ({\n      start: LTR ? getOffset(tab, this.wrapper).left : Math.abs(getOffset(tab, this.wrapper).right),\n      width: tab.offsetWidth\n    })).filter(offset => next ? offset.start + offset.width > pivot : offset.start < pivot).at(next ? 0 : -1).width;\n    amount *= next ? 1 : -1;\n    this.container.scrollBy({\n      left: LTR ? amount : -amount\n    });\n  }\n  handleClick(event) {\n    const target = event.target;\n    const tab = target.closest('igc-tab');\n    if (!(tab && this.contains(tab)) || tab.disabled) {\n      return;\n    }\n    tab.focus();\n    this.setSelectedTab(tab);\n    this.emitEvent('igcChange', {\n      detail: this.activeTab\n    });\n  }\n  handleScroll() {\n    this.updateScrollButtons();\n  }\n  select(name) {\n    this.setSelectedTab(this.tabs.find(el => el.panel === name));\n  }\n  renderScrollButton(direction) {\n    const start = direction === 'start';\n    return this.showScrollButtons ? html`<igc-icon-button\n          tabindex=\"-1\"\n          aria-hidden=\"true\"\n          size=\"large\"\n          variant=\"flat\"\n          collection=\"internal\"\n          part=\"${direction}-scroll-button\"\n          name=\"navigate_${start ? 'before' : 'next'}\"\n          .disabled=${start ? this.disableStartScrollButton : this.disableEndScrollButton}\n          @click=${() => this.scrollByTabOffset(direction)}\n        ></igc-icon-button>` : nothing;\n  }\n  render() {\n    return html`\n      <div part=\"headers\">\n        ${this.renderScrollButton('start')}\n        <div part=\"headers-content\" @scroll=${this.handleScroll}>\n          <div part=\"headers-wrapper\">\n            <div\n              part=\"headers-scroll\"\n              role=\"tablist\"\n              @click=${this.handleClick}\n              @keydown=${this.handleKeyDown}\n            >\n              <slot></slot>\n            </div>\n            <div part=\"selected-indicator\"></div>\n          </div>\n        </div>\n        ${this.renderScrollButton('end')}\n      </div>\n      <div part=\"content\">\n        <slot name=\"panel\"></slot>\n      </div>\n    `;\n  }\n};\nIgcTabsComponent.tagName = 'igc-tabs';\nIgcTabsComponent.styles = styles;\nIgcTabsComponent.increment = createCounter();\n__decorate([queryAssignedElements({\n  selector: 'igc-tab'\n})], IgcTabsComponent.prototype, \"tabs\", void 0);\n__decorate([queryAssignedElements({\n  slot: 'panel'\n})], IgcTabsComponent.prototype, \"panels\", void 0);\n__decorate([query('[part=\"headers-wrapper\"]', true)], IgcTabsComponent.prototype, \"wrapper\", void 0);\n__decorate([query('[part=\"headers-content\"]', true)], IgcTabsComponent.prototype, \"container\", void 0);\n__decorate([query('[part=\"selected-indicator\"]', true)], IgcTabsComponent.prototype, \"selectedIndicator\", void 0);\n__decorate([state()], IgcTabsComponent.prototype, \"showScrollButtons\", void 0);\n__decorate([state()], IgcTabsComponent.prototype, \"disableStartScrollButton\", void 0);\n__decorate([state()], IgcTabsComponent.prototype, \"disableEndScrollButton\", void 0);\n__decorate([state()], IgcTabsComponent.prototype, \"activeTab\", void 0);\n__decorate([property({\n  reflect: true\n})], IgcTabsComponent.prototype, \"alignment\", void 0);\n__decorate([property()], IgcTabsComponent.prototype, \"activation\", void 0);\n__decorate([watch('alignment', {\n  waitUntilFirstUpdate: true\n})], IgcTabsComponent.prototype, \"alignIndicator\", null);\n__decorate([eventOptions({\n  passive: true\n})], IgcTabsComponent.prototype, \"handleScroll\", null);\nIgcTabsComponent = IgcTabsComponent_1 = __decorate([themes({\n  bootstrap,\n  fluent,\n  indigo\n}), blazorAdditionalDependencies('IgcTabComponent, IgcTabPanelComponent')], IgcTabsComponent);\nexport default IgcTabsComponent;","map":{"version":3,"names":["html","LitElement","nothing","eventOptions","property","query","queryAssignedElements","state","watch","blazorAdditionalDependencies","themes","styles","bootstrap","fluent","indigo","EventEmitterMixin","createCounter","getOffset","isLTR","getAttributesForTags","getNodesForTags","observerConfig","defineComponents","IgcTabComponent","IgcTabPanelComponent","IgcIconButtonComponent","IgcTabsComponent","IgcTabsComponent_1","constructor","showScrollButtons","disableStartScrollButton","disableEndScrollButton","alignment","activation","handleKeyDown","event","key","enabledTabs","ltr","index","indexOf","_a","document","activeElement","closest","length","setSelectedTab","focus","preventScroll","emitEvent","detail","activeTab","scrollIntoView","block","preventDefault","tabs","filter","tab","disabled","selected","_b","panel","alignIndicator","visibility","transitionDuration","Object","assign","width","offsetWidth","transform","wrapper","left","right","selectedIndicator","style","firstUpdated","container","scrollWidth","clientWidth","updateComplete","syncAttributes","setupObserver","at","updateSelectedTab","disconnectedCallback","resizeObserver","disconnect","mutationObserver","updateButtonsOnResize","performUpdate","updateScrollButtons","scrollLeft","Math","abs","ResizeObserver","forEach","element","observe","MutationObserver","records","observer","attributes","changed","find","addedNodes","removedNodes","unobserve","undefined","panels","hidden","id","prefix","increment","_c","setAttribute","scrollByTabOffset","direction","LTR","next","pivot","amount","map","start","offset","scrollBy","handleClick","target","contains","handleScroll","select","name","el","renderScrollButton","render","tagName","__decorate","selector","slot","reflect","waitUntilFirstUpdate","passive"],"sources":["../../../src/components/tabs/tabs.ts"],"sourcesContent":["import { html, LitElement, nothing } from 'lit';\nimport {\n  eventOptions,\n  property,\n  query,\n  queryAssignedElements,\n  state,\n} from 'lit/decorators.js';\nimport { watch } from '../common/decorators/watch.js';\nimport { blazorAdditionalDependencies } from '../common/decorators/blazorAdditionalDependencies.js';\nimport { themes } from '../../theming/theming-decorator.js';\nimport { styles } from './themes/light/tabs.base.css.js';\nimport { styles as bootstrap } from './themes/light/tabs.bootstrap.css.js';\nimport { styles as fluent } from './themes/light/tabs.fluent.css.js';\nimport { styles as indigo } from './themes/light/tabs.indigo.css.js';\nimport { EventEmitterMixin } from '../common/mixins/event-emitter.js';\nimport { Constructor } from '../common/mixins/constructor.js';\nimport { createCounter, getOffset, isLTR } from '../common/util.js';\nimport {\n  getAttributesForTags,\n  getNodesForTags,\n  observerConfig,\n} from './utils.js';\n\nimport { defineComponents } from '../common/definitions/defineComponents.js';\nimport IgcTabComponent from './tab.js';\nimport IgcTabPanelComponent from './tab-panel.js';\nimport IgcIconButtonComponent from '../button/icon-button.js';\n\ndefineComponents(IgcTabComponent, IgcTabPanelComponent, IgcIconButtonComponent);\n\nexport interface IgcTabsEventMap {\n  igcChange: CustomEvent<IgcTabComponent>;\n}\n\n/**\n * Represents tabs component\n *\n * @element igc-tabs\n *\n * @fires igcChange - Emitted when the selected tab changes.\n *\n * @slot - Renders the tab header.\n * @slot panel - Renders the tab content.\n *\n * @csspart headers - The wrapper of the tabs including the headers content and the scroll buttons.\n * @csspart headers-content - The container for the tab headers.\n * @csspart headers-wrapper - The wrapper for the tab headers and the selected indicator.\n * @csspart headers-scroll - The container for the headers.\n * @csspart selected-indicator - The selected indicator.\n * @csspart start-scroll-button - The start scroll button displayed when the tabs overflow.\n * @csspart end-scroll-button - The end scroll button displayed when the tabs overflow.\n * @csspart content - The container for the tabs content.\n */\n@themes({ bootstrap, fluent, indigo })\n@blazorAdditionalDependencies('IgcTabComponent, IgcTabPanelComponent')\nexport default class IgcTabsComponent extends EventEmitterMixin<\n  IgcTabsEventMap,\n  Constructor<LitElement>\n>(LitElement) {\n  public static readonly tagName = 'igc-tabs';\n\n  public static styles = styles;\n  private static readonly increment = createCounter();\n\n  @queryAssignedElements({ selector: 'igc-tab' })\n  protected tabs!: Array<IgcTabComponent>;\n\n  @queryAssignedElements({ slot: 'panel' })\n  protected panels!: Array<IgcTabPanelComponent>;\n\n  @query('[part=\"headers-wrapper\"]', true)\n  protected wrapper!: HTMLElement;\n\n  @query('[part=\"headers-content\"]', true)\n  protected container!: HTMLElement;\n\n  @query('[part=\"selected-indicator\"]', true)\n  protected selectedIndicator!: HTMLElement;\n\n  @state()\n  protected showScrollButtons = false;\n\n  @state()\n  protected disableStartScrollButton = true;\n\n  @state()\n  protected disableEndScrollButton = false;\n\n  @state()\n  protected activeTab?: IgcTabComponent;\n\n  protected resizeObserver!: ResizeObserver;\n  protected mutationObserver!: MutationObserver;\n\n  protected get enabledTabs() {\n    return this.tabs.filter((tab) => !tab.disabled);\n  }\n\n  /** Returns the currently selected tab. */\n  public get selected(): string {\n    return this.activeTab?.panel ?? '';\n  }\n\n  /**\n   * Sets the alignment for the tab headers\n   * @attr\n   */\n  @property({ reflect: true })\n  public alignment: 'start' | 'end' | 'center' | 'justify' = 'start';\n\n  /**\n   * Determines the tab activation. When set to auto,\n   * the tab is instantly selected while navigating with the Left/Right Arrows, Home or End keys\n   * and the corresponding panel is displayed.\n   * When set to manual, the tab is only focused. The selection happens after pressing Space or Enter.\n   * @attr\n   */\n  @property()\n  public activation: 'auto' | 'manual' = 'auto';\n\n  @watch('alignment', { waitUntilFirstUpdate: true })\n  protected alignIndicator() {\n    const styles: Partial<CSSStyleDeclaration> = {\n      visibility: this.activeTab ? 'visible' : 'hidden',\n      transitionDuration: '0.3s',\n    };\n\n    if (this.activeTab) {\n      Object.assign(styles, {\n        width: `${this.activeTab!.offsetWidth}px`,\n        transform: `translate(${\n          isLTR(this)\n            ? getOffset(this.activeTab!, this.wrapper).left\n            : getOffset(this.activeTab!, this.wrapper).right\n        }px)`,\n      });\n    }\n\n    Object.assign(this.selectedIndicator.style, styles);\n  }\n\n  protected override async firstUpdated() {\n    this.showScrollButtons =\n      this.container.scrollWidth > this.container.clientWidth;\n\n    await this.updateComplete;\n\n    this.syncAttributes();\n    this.setupObserver();\n    this.setSelectedTab(\n      this.tabs.filter((tab) => tab.selected).at(-1) ?? this.enabledTabs.at(0)\n    );\n    this.updateSelectedTab();\n  }\n\n  public override disconnectedCallback() {\n    this.resizeObserver?.disconnect();\n    this.mutationObserver?.disconnect();\n    super.disconnectedCallback();\n  }\n\n  protected updateButtonsOnResize() {\n    // Hide the buttons in the resize observer callback and synchronously update the DOM\n    // in order to get the actual size\n    this.showScrollButtons = false;\n    this.performUpdate();\n\n    this.showScrollButtons =\n      this.container.scrollWidth > this.container.clientWidth;\n\n    this.updateScrollButtons();\n  }\n\n  protected updateScrollButtons() {\n    const { scrollLeft, offsetWidth } = this.container,\n      { scrollWidth } = this.wrapper;\n\n    this.disableEndScrollButton =\n      scrollWidth <= Math.abs(scrollLeft) + offsetWidth;\n    this.disableStartScrollButton = scrollLeft === 0;\n  }\n\n  protected setupObserver() {\n    this.resizeObserver = new ResizeObserver(() => {\n      this.updateButtonsOnResize();\n      this.alignIndicator();\n    });\n\n    [this.container, this.wrapper, ...this.tabs].forEach((element) =>\n      this.resizeObserver.observe(element)\n    );\n\n    this.mutationObserver = new MutationObserver(async (records, observer) => {\n      // Stop observing while handling changes\n      observer.disconnect();\n\n      const attributes = getAttributesForTags<IgcTabComponent>(\n        records,\n        'igc-tab'\n      );\n      const changed = getNodesForTags<IgcTabComponent>(\n        records,\n        this,\n        'igc-tab'\n      );\n\n      if (attributes.length > 0) {\n        this.activeTab = attributes.find((tab) => tab.selected);\n      }\n\n      if (changed) {\n        changed.addedNodes.forEach((tab) => {\n          this.resizeObserver.observe(tab);\n          if (tab.selected) {\n            this.activeTab = tab;\n          }\n        });\n        changed.removedNodes.forEach((tab) => {\n          this.resizeObserver.unobserve(tab);\n          if (tab.selected || this.activeTab === tab) {\n            this.activeTab = undefined;\n          }\n        });\n\n        this.syncAttributes();\n      }\n\n      this.updateSelectedTab();\n      this.activeTab?.scrollIntoView({ block: 'nearest' });\n      this.alignIndicator();\n\n      // Watch for changes again\n      await this.updateComplete;\n      observer.observe(this, observerConfig);\n    });\n\n    this.mutationObserver.observe(this, observerConfig);\n  }\n\n  protected updateSelectedTab() {\n    this.tabs.forEach((tab) => (tab.selected = tab === this.activeTab));\n    this.panels.forEach((panel) => {\n      panel.hidden = panel.id !== this.activeTab?.panel;\n    });\n  }\n\n  protected syncAttributes() {\n    const prefix = this.id ? `${this.id}-` : '';\n    this.tabs.forEach((tab, index) => {\n      if (!tab.panel) {\n        tab.panel =\n          this.panels.at(index)?.id ??\n          `${prefix}tab-${IgcTabsComponent.increment()}`;\n      }\n      this.panels\n        .find((panel) => panel.id === tab.panel)\n        ?.setAttribute('aria-labelledby', tab.id);\n    });\n  }\n\n  private setSelectedTab(tab?: IgcTabComponent) {\n    if (!tab || tab === this.activeTab) {\n      return;\n    }\n\n    if (this.activeTab) {\n      this.activeTab.selected = false;\n    }\n\n    this.activeTab = tab;\n    this.activeTab.selected = true;\n  }\n\n  protected scrollByTabOffset(direction: 'start' | 'end') {\n    const { scrollLeft, offsetWidth } = this.container;\n    const LTR = isLTR(this),\n      next = direction === 'end';\n\n    const pivot = Math.abs(next ? offsetWidth + scrollLeft : scrollLeft);\n\n    let amount = this.tabs\n      .map((tab) => ({\n        start: LTR\n          ? getOffset(tab, this.wrapper).left\n          : Math.abs(getOffset(tab, this.wrapper).right),\n        width: tab.offsetWidth,\n      }))\n      .filter((offset) =>\n        next ? offset.start + offset.width > pivot : offset.start < pivot\n      )\n      .at(next ? 0 : -1)!.width;\n\n    amount *= next ? 1 : -1;\n    this.container.scrollBy({ left: LTR ? amount : -amount });\n  }\n\n  protected handleClick(event: MouseEvent) {\n    const target = event.target as HTMLElement;\n    const tab = target.closest('igc-tab');\n\n    if (!(tab && this.contains(tab)) || tab.disabled) {\n      return;\n    }\n\n    tab.focus();\n    this.setSelectedTab(tab);\n    this.emitEvent('igcChange', { detail: this.activeTab });\n  }\n\n  protected handleKeyDown = (event: KeyboardEvent) => {\n    const { key } = event;\n    const enabledTabs = this.enabledTabs;\n    const ltr = isLTR(this);\n\n    let index = enabledTabs.indexOf(\n      document.activeElement?.closest('igc-tab') as IgcTabComponent\n    );\n\n    switch (key) {\n      case 'ArrowLeft':\n        index = ltr\n          ? (enabledTabs.length + index - 1) % enabledTabs.length\n          : (index + 1) % enabledTabs.length;\n        break;\n      case 'ArrowRight':\n        index = ltr\n          ? (index + 1) % enabledTabs.length\n          : (enabledTabs.length + index - 1) % enabledTabs.length;\n        break;\n      case 'Home':\n        index = 0;\n        break;\n      case 'End':\n        index = enabledTabs.length - 1;\n        break;\n      case 'Enter':\n      case ' ':\n        this.setSelectedTab(enabledTabs[index]);\n        break;\n      default:\n        return;\n    }\n\n    enabledTabs[index].focus({ preventScroll: true });\n\n    if (this.activation === 'auto') {\n      this.setSelectedTab(enabledTabs[index]);\n      this.emitEvent('igcChange', { detail: this.activeTab });\n    } else {\n      enabledTabs[index].scrollIntoView({ block: 'nearest' });\n    }\n\n    event.preventDefault();\n  };\n\n  @eventOptions({ passive: true })\n  protected handleScroll() {\n    this.updateScrollButtons();\n  }\n\n  /** Selects the specified tab and displays the corresponding panel.  */\n  public select(name: string) {\n    this.setSelectedTab(this.tabs.find((el) => el.panel === name));\n  }\n\n  protected renderScrollButton(direction: 'start' | 'end') {\n    const start = direction === 'start';\n\n    return this.showScrollButtons\n      ? html`<igc-icon-button\n          tabindex=\"-1\"\n          aria-hidden=\"true\"\n          size=\"large\"\n          variant=\"flat\"\n          collection=\"internal\"\n          part=\"${direction}-scroll-button\"\n          name=\"navigate_${start ? 'before' : 'next'}\"\n          .disabled=${start\n            ? this.disableStartScrollButton\n            : this.disableEndScrollButton}\n          @click=${() => this.scrollByTabOffset(direction)}\n        ></igc-icon-button>`\n      : nothing;\n  }\n\n  protected override render() {\n    return html`\n      <div part=\"headers\">\n        ${this.renderScrollButton('start')}\n        <div part=\"headers-content\" @scroll=${this.handleScroll}>\n          <div part=\"headers-wrapper\">\n            <div\n              part=\"headers-scroll\"\n              role=\"tablist\"\n              @click=${this.handleClick}\n              @keydown=${this.handleKeyDown}\n            >\n              <slot></slot>\n            </div>\n            <div part=\"selected-indicator\"></div>\n          </div>\n        </div>\n        ${this.renderScrollButton('end')}\n      </div>\n      <div part=\"content\">\n        <slot name=\"panel\"></slot>\n      </div>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'igc-tabs': IgcTabsComponent;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}