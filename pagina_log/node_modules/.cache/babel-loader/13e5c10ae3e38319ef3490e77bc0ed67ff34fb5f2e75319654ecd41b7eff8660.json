{"ast":null,"code":"import DataOperation from './base.js';\nexport default class FilterDataOperation extends DataOperation {\n  resolveFilter(record, expr) {\n    const condition = expr.condition;\n    return condition.logic(\n    // XXX: Types\n    // @ts-expect-error - resolve\n    this.resolveValue(record, expr.key), expr.searchTerm, expr.caseSensitive);\n  }\n  match(record, ands, ors) {\n    for (const or of ors) {\n      if (this.resolveFilter(record, or)) {\n        return this.match(record, ands.filter(f => f.key !== or.key), []);\n      }\n    }\n    return ands.every(f => this.resolveFilter(record, f));\n  }\n  apply(data, state) {\n    if (state.empty) return data;\n    const {\n      ands,\n      ors\n    } = state;\n    return data.filter(record => this.match(record, ands, ors));\n  }\n}","map":{"version":3,"names":["DataOperation","FilterDataOperation","resolveFilter","record","expr","condition","logic","resolveValue","key","searchTerm","caseSensitive","match","ands","ors","or","filter","f","every","apply","data","state","empty"],"sources":["../../../src/operations/filter.ts"],"sourcesContent":["import DataOperation from './base.js';\nimport type { FilterState } from './filter/state.js';\nimport type { FilterExpression, FilterOperation } from './filter/types.js';\n\nexport default class FilterDataOperation<T extends object> extends DataOperation<T> {\n  protected resolveFilter(record: T, expr: FilterExpression<T>) {\n    const condition = expr.condition as FilterOperation<T>;\n    return condition.logic(\n      // XXX: Types\n      // @ts-expect-error - resolve\n      this.resolveValue(record, expr.key),\n      expr.searchTerm,\n      expr.caseSensitive,\n    );\n  }\n\n  protected match(record: T, ands: FilterExpression<T>[], ors: FilterExpression<T>[]): boolean {\n    for (const or of ors) {\n      if (this.resolveFilter(record, or)) {\n        return this.match(\n          record,\n          ands.filter(f => f.key !== or.key),\n          [],\n        );\n      }\n    }\n    return ands.every(f => this.resolveFilter(record, f));\n  }\n\n  public apply(data: T[], state: FilterState<T>): T[] {\n    if (state.empty) return data;\n\n    const { ands, ors } = state;\n    return data.filter(record => this.match(record, ands, ors));\n  }\n}\n"],"mappings":"AAAA,OAAOA,aAAa,MAAM,WAAW;AAIrC,eAAc,MAAOC,mBAAsC,SAAQD,aAAgB;EACvEE,aAAaA,CAACC,MAAS,EAAEC,IAAyB;IAC1D,MAAMC,SAAS,GAAGD,IAAI,CAACC,SAA+B;IACtD,OAAOA,SAAS,CAACC,KAAK;IACpB;IACA;IACA,IAAI,CAACC,YAAY,CAACJ,MAAM,EAAEC,IAAI,CAACI,GAAG,CAAC,EACnCJ,IAAI,CAACK,UAAU,EACfL,IAAI,CAACM,aAAa,CACnB;EACH;EAEUC,KAAKA,CAACR,MAAS,EAAES,IAA2B,EAAEC,GAA0B;IAChF,KAAK,MAAMC,EAAE,IAAID,GAAG,EAAE;MACpB,IAAI,IAAI,CAACX,aAAa,CAACC,MAAM,EAAEW,EAAE,CAAC,EAAE;QAClC,OAAO,IAAI,CAACH,KAAK,CACfR,MAAM,EACNS,IAAI,CAACG,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACR,GAAG,KAAKM,EAAE,CAACN,GAAG,CAAC,EAClC,EAAE,CACH;;;IAGL,OAAOI,IAAI,CAACK,KAAK,CAACD,CAAC,IAAI,IAAI,CAACd,aAAa,CAACC,MAAM,EAAEa,CAAC,CAAC,CAAC;EACvD;EAEOE,KAAKA,CAACC,IAAS,EAAEC,KAAqB;IAC3C,IAAIA,KAAK,CAACC,KAAK,EAAE,OAAOF,IAAI;IAE5B,MAAM;MAAEP,IAAI;MAAEC;IAAG,CAAE,GAAGO,KAAK;IAC3B,OAAOD,IAAI,CAACJ,MAAM,CAACZ,MAAM,IAAI,IAAI,CAACQ,KAAK,CAACR,MAAM,EAAES,IAAI,EAAEC,GAAG,CAAC,CAAC;EAC7D"},"metadata":{},"sourceType":"module","externalDependencies":[]}