{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport getResizeObserver from './polyfillLoaders/ResizeObserver.js';\nimport { RangeChangedEvent, VisibilityChangedEvent, UnpinnedEvent } from './events.js';\nimport { ScrollerController } from './ScrollerController.js';\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\nlet DefaultLayoutConstructor;\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  constructor(config) {\n    this._benchmarkStart = null;\n    this._layout = null;\n    this._clippingAncestors = [];\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n    this._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n    this._scrollError = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n    this._childrenPos = null;\n    // TODO: (graynorton): type\n    this._childMeasurements = null;\n    this._toBeMeasured = new Map();\n    this._rangeChanged = true;\n    this._itemsChanged = true;\n    this._visibilityChanged = true;\n    this._scrollerController = null;\n    this._isScroller = false;\n    this._sizer = null;\n    /**\n     * Resize observer attached to hostElement.\n     */\n    this._hostElementRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n    this._childrenRO = null;\n    this._mutationObserver = null;\n    this._scrollEventListeners = [];\n    this._scrollEventListenerOptions = {\n      passive: true\n    };\n    // TODO (graynorton): Rethink, per longer comment below\n    this._loadListener = this._childLoaded.bind(this);\n    /**\n     * Index of element to scroll into view, plus scroll\n     * behavior options, as imperatively specified via\n     * `element(index).scrollIntoView()`\n     */\n    this._scrollIntoViewTarget = null;\n    this._updateScrollIntoViewCoordinates = null;\n    /**\n     * Items to render. Set by items.\n     */\n    this._items = [];\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child in the range.\n     */\n    this._last = -1;\n    /**\n     * Index of the first item intersecting the viewport.\n     */\n    this._firstVisible = -1;\n    /**\n     * Index of the last item intersecting the viewport.\n     */\n    this._lastVisible = -1;\n    this._scheduled = new WeakSet();\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n    this._measureCallback = null;\n    this._measureChildOverride = null;\n    /**\n     * State for `layoutComplete` promise\n     */\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n    if (!config) {\n      throw new Error('Virtualizer constructor requires a configuration object');\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n    }\n  }\n  set items(items) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n  _init(config) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    this._initLayout(config.layout || {});\n  }\n  async _initObservers() {\n    this._mutationObserver = new MutationObserver(this._finishDOMUpdate.bind(this));\n    const ResizeObserver = await getResizeObserver();\n    this._hostElementRO = new ResizeObserver(() => this._hostElementSizeChanged());\n    this._childrenRO = new ResizeObserver(this._childrenSizeChanged.bind(this));\n  }\n  _initHostElement(config) {\n    const hostElement = this._hostElement = config.hostElement;\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n  async connected() {\n    await this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n    this._scrollerController = new ScrollerController(this, this._clippingAncestors[0]);\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n  }\n  _observeAndListen() {\n    this._mutationObserver.observe(this._hostElement, {\n      childList: true\n    });\n    this._hostElementRO.observe(this._hostElement);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', this, this._scrollEventListenerOptions);\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO.observe(ancestor);\n    });\n    this._hostElementRO.observe(this._scrollerController.element);\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._scrollEventListeners.forEach(target => target.addEventListener('scroll', this, this._scrollEventListenerOptions));\n  }\n  disconnected() {\n    var _a, _b, _c, _d;\n    this._scrollEventListeners.forEach(target => target.removeEventListener('scroll', this, this._scrollEventListenerOptions));\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController = ((_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.detach(this)) || null;\n    (_b = this._mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n    (_c = this._hostElementRO) === null || _c === void 0 ? void 0 : _c.disconnect();\n    (_d = this._childrenRO) === null || _d === void 0 ? void 0 : _d.disconnect();\n    this._rejectLayoutCompletePromise('disconnected');\n  }\n  _applyVirtualizerStyles() {\n    const hostElement = this._hostElement;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style;\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n  _getSizer() {\n    const hostElement = this._hostElement;\n    if (!this._sizer) {\n      // Use a pre-existing sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px'\n      });\n      sizer.innerHTML = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n  updateLayoutConfig(layoutConfig) {\n    const Ctor = layoutConfig.type || DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {\n        ...layoutConfig\n      };\n      delete config.type;\n      this._layout.config = config;\n      return true;\n    }\n    return false;\n  }\n  async _initLayout(layoutConfig) {\n    let config;\n    let Ctor;\n    if (typeof layoutConfig.type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = layoutConfig.type;\n      // ...while the rest of the specifier is our layout config\n      const copy = {\n        ...layoutConfig\n      };\n      delete copy.type;\n      config = copy;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig;\n    }\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js')).FlowLayout;\n    }\n    this._layout = new Ctor(config);\n    if (this._layout.measureChildren && typeof this._layout.updateItemSizes === 'function') {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n    this._layout.addEventListener('scrollsizechange', this);\n    this._layout.addEventListener('scrollerrorchange', this);\n    this._layout.addEventListener('itempositionchange', this);\n    this._layout.addEventListener('rangechange', this);\n    this._layout.addEventListener('unpinned', this);\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement.addEventListener('load', this._loadListener, true);\n    }\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n      const virtualizationTime = entries.filter(e => e.startTime >= this._benchmarkStart && e.startTime < now).reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {\n        timeElapsed,\n        virtualizationTime\n      };\n    }\n    return null;\n  }\n  _measureChildren() {\n    const mm = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element) {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {\n      width,\n      height\n    } = element.getBoundingClientRect();\n    return Object.assign({\n      width,\n      height\n    }, getMargins(element));\n  }\n  async _schedule(method) {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n  async _updateDOM() {\n    const {\n      _rangeChanged,\n      _itemsChanged\n    } = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    } else {\n      this._finishDOMUpdate();\n    }\n  }\n  _finishDOMUpdate() {\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._checkScrollIntoViewTarget(this._childrenPos);\n    this._positionChildren(this._childrenPos);\n    this._sizeHostElement(this._scrollSize);\n    this._correctScrollError();\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n  _updateLayout() {\n    if (this._layout) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n  _handleScrollEvent() {\n    var _a;\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      (_a = this._layout) === null || _a === void 0 ? void 0 : _a.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n  handleEvent(event) {\n    switch (event.type) {\n      case 'scroll':\n        if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {\n          this._handleScrollEvent();\n        }\n        break;\n      case 'scrollsizechange':\n        this._scrollSize = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'scrollerrorchange':\n        this._scrollError = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'itempositionchange':\n        this._childrenPos = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'rangechange':\n        this._adjustRange(event.detail);\n        this._schedule(this._updateDOM);\n        break;\n      case 'unpinned':\n        this._hostElement.dispatchEvent(new UnpinnedEvent());\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n  get _children() {\n    const arr = [];\n    let next = this._hostElement.firstElementChild;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling;\n    }\n    return arr;\n  }\n  _updateView() {\n    var _a;\n    const hostElement = this._hostElement;\n    const scrollingElement = (_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.element;\n    const layout = this._layout;\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n      const hostElementBounds = hostElement.getBoundingClientRect();\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n      const ancestorBounds = this._clippingAncestors.map(ancestor => ancestor.getBoundingClientRect());\n      ancestorBounds.unshift(hostElementBounds);\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top\n      };\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight\n      };\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n      const height = Math.max(1, bottom - top);\n      const width = Math.max(1, right - left);\n      layout.viewportSize = {\n        width,\n        height\n      };\n      layout.viewportScroll = {\n        top: scrollTop,\n        left: scrollLeft\n      };\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  _sizeHostElement(size) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement.style;\n      style.minWidth = h ? `${h}px` : '100%';\n      style.minHeight = v ? `${v}px` : '100%';\n    }\n  }\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  _positionChildren(pos) {\n    if (pos) {\n      pos.forEach(({\n        top,\n        left,\n        width,\n        height,\n        xOffset,\n        yOffset\n      }, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          child.style.left = xOffset === undefined ? null : xOffset + 'px';\n          child.style.top = yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n  async _adjustRange(range) {\n    const {\n      _first,\n      _last,\n      _firstVisible,\n      _lastVisible\n    } = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged = this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged = this._visibilityChanged || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible;\n  }\n  _correctScrollError() {\n    if (this._scrollError) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this._scrollerController;\n      const {\n        top,\n        left\n      } = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left\n      });\n    }\n  }\n  element(index) {\n    var _a;\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return ((_a = this._items) === null || _a === void 0 ? void 0 : _a[index]) === undefined ? undefined : {\n      scrollIntoView: (options = {}) => this._scrollElementIntoView({\n        ...options,\n        index\n      })\n    };\n  }\n  _scrollElementIntoView(options) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout.getScrollIntoViewCoordinates(options);\n        const {\n          behavior\n        } = options;\n        this._updateScrollIntoViewCoordinates = this._scrollerController.managedScrollTo(Object.assign(coordinates, {\n          behavior\n        }), () => this._layout.getScrollIntoViewCoordinates(options), () => this._scrollIntoViewTarget = null);\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout.pin = options;\n      }\n    }\n  }\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  _checkScrollIntoViewTarget(pos) {\n    const {\n      index\n    } = this._scrollIntoViewTarget || {};\n    if (index && (pos === null || pos === void 0 ? void 0 : pos.has(index))) {\n      this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));\n    }\n  }\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  _notifyRange() {\n    this._hostElement.dispatchEvent(new RangeChangedEvent({\n      first: this._first,\n      last: this._last\n    }));\n  }\n  _notifyVisibility() {\n    this._hostElement.dispatchEvent(new VisibilityChangedEvent({\n      first: this._firstVisible,\n      last: this._lastVisible\n    }));\n  }\n  get layoutComplete() {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n  _rejectLayoutCompletePromise(reason) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n  _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() => requestAnimationFrame(() => this._resolveLayoutCompletePromise()));\n    }\n  }\n  _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n  _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n  _childLoaded() {}\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  _childrenSizeChanged(changes) {\n    // Only measure if the layout requires it\n    if (this._layout.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(change.target, change.contentRect);\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\nfunction getMargins(el) {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\nfunction getMarginValue(value) {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return parentNode.host || null;\n  }\n  return null;\n}\n///\nfunction getElementAncestors(el, includeSelf = false) {\n  const ancestors = [];\n  let parent = includeSelf ? el : getParentElement(el);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent);\n  }\n  return ancestors;\n}\nfunction getClippingAncestors(el, includeSelf = false) {\n  return getElementAncestors(el, includeSelf).filter(a => getComputedStyle(a).overflow !== 'visible');\n}","map":{"version":3,"names":["getResizeObserver","RangeChangedEvent","VisibilityChangedEvent","UnpinnedEvent","ScrollerController","virtualizerRef","Symbol","SIZER_ATTRIBUTE","DefaultLayoutConstructor","Virtualizer","constructor","config","_benchmarkStart","_layout","_clippingAncestors","_scrollSize","_scrollError","_childrenPos","_childMeasurements","_toBeMeasured","Map","_rangeChanged","_itemsChanged","_visibilityChanged","_scrollerController","_isScroller","_sizer","_hostElementRO","_childrenRO","_mutationObserver","_scrollEventListeners","_scrollEventListenerOptions","passive","_loadListener","_childLoaded","bind","_scrollIntoViewTarget","_updateScrollIntoViewCoordinates","_items","_first","_last","_firstVisible","_lastVisible","_scheduled","WeakSet","_measureCallback","_measureChildOverride","_layoutCompletePromise","_layoutCompleteResolver","_layoutCompleteRejecter","_pendingLayoutComplete","Error","hostElement","_init","items","Array","isArray","_schedule","_updateLayout","scroller","_initHostElement","_initLayout","layout","_initObservers","MutationObserver","_finishDOMUpdate","ResizeObserver","_hostElementSizeChanged","_childrenSizeChanged","_hostElement","_applyVirtualizerStyles","connected","includeSelf","getClippingAncestors","_observeAndListen","observe","childList","push","window","addEventListener","forEach","ancestor","element","_children","child","target","disconnected","removeEventListener","_a","detach","_b","disconnect","_c","_d","_rejectLayoutCompletePromise","style","display","position","contain","overflow","minHeight","_getSizer","sizer","querySelector","document","createElement","setAttribute","appendChild","Object","assign","margin","padding","visibility","fontSize","innerHTML","updateLayoutConfig","layoutConfig","Ctor","type","copy","undefined","FlowLayout","measureChildren","updateItemSizes","listenForChildLoadEvents","startBenchmarking","performance","now","stopBenchmarking","timeElapsed","entries","getEntriesByName","virtualizationTime","filter","e","startTime","reduce","t","m","duration","_measureChildren","mm","children","fn","_measureChild","i","length","idx","has","call","clear","width","height","getBoundingClientRect","getMargins","method","add","Promise","resolve","delete","_updateDOM","_notifyVisibility","_notifyRange","_checkScrollIntoViewTarget","_positionChildren","_sizeHostElement","_correctScrollError","mark","_updateView","reflowIfNeeded","_handleScrollEvent","measure","console","warn","correctingScrollError","unpin","handleEvent","event","currentTarget","includes","detail","_adjustRange","dispatchEvent","arr","next","firstElementChild","hasAttribute","nextElementSibling","scrollingElement","top","left","bottom","right","hostElementBounds","innerHeight","innerWidth","ancestorBounds","map","unshift","bounds","Math","max","min","scrollingElementBounds","offsetWithinScroller","totalScrollSize","scrollWidth","scrollHeight","scrollTop","scrollLeft","viewportSize","viewportScroll","size","h","v","transform","minWidth","pos","xOffset","yOffset","index","boxSizing","range","first","last","firstVisible","lastVisible","correctScrollError","Infinity","scrollIntoView","options","_scrollElementIntoView","behavior","coordinates","getScrollIntoViewCoordinates","managedScrollTo","pin","layoutComplete","reject","reason","_resetLayoutCompleteState","_scheduleLayoutComplete","requestAnimationFrame","_resolveLayoutCompletePromise","changes","change","set","contentRect","el","getComputedStyle","marginTop","getMarginValue","marginRight","marginBottom","marginLeft","value","float","parseFloat","NaN","Number","isNaN","getParentElement","assignedSlot","parentElement","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","getElementAncestors","ancestors","parent","a"],"sources":["src/Virtualizer.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport getResizeObserver from './polyfillLoaders/ResizeObserver.js';\nimport {\n  ItemBox,\n  Margins,\n  LayoutConfigValue,\n  ChildPositions,\n  ChildMeasurements,\n  Layout,\n  LayoutConstructor,\n  LayoutSpecifier,\n  Size,\n  InternalRange,\n  MeasureChildFunction,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n} from './layouts/shared/Layout.js';\nimport {\n  RangeChangedEvent,\n  VisibilityChangedEvent,\n  UnpinnedEvent,\n} from './events.js';\nimport {ScrollerController} from './ScrollerController.js';\n\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\n\ndeclare global {\n  interface HTMLElementEventMap {\n    rangeChanged: RangeChangedEvent;\n    visibilityChanged: VisibilityChangedEvent;\n    unpinned: UnpinnedEvent;\n  }\n}\n\nexport interface VirtualizerHostElement extends HTMLElement {\n  [virtualizerRef]?: Virtualizer;\n}\n\n/**\n * A very limited proxy object for a virtualizer child,\n * returned by Virtualizer.element(idx: number). Introduced\n * to enable scrolling a virtual element into view using\n * a call that looks and behaves essentially the same as for\n * a real Element. May be useful for other things later.\n */\nexport interface VirtualizerChildElementProxy {\n  scrollIntoView: (options?: ScrollIntoViewOptions) => void;\n}\n\n/**\n * Used internally for scrolling a (possibly virtual) element\n * into view, given its index\n */\ninterface ScrollElementIntoViewOptions extends ScrollIntoViewOptions {\n  index: number;\n}\n\nexport interface VirtualizerConfig {\n  layout?: LayoutConfigValue;\n\n  /**\n   * The parent of all child nodes to be rendered.\n   */\n  hostElement: VirtualizerHostElement;\n\n  scroller?: boolean;\n}\n\nlet DefaultLayoutConstructor: LayoutConstructor;\n\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  private _benchmarkStart: number | null = null;\n\n  private _layout: Layout | null = null;\n\n  private _clippingAncestors: HTMLElement[] = [];\n\n  /**\n   * Layout provides these values, we set them on _render().\n   * TODO @straversi: Can we find an XOR type, usable for the key here?\n   */\n  private _scrollSize: Size | null = null;\n\n  /**\n   * Difference between scroll target's current and required scroll offsets.\n   * Provided by layout.\n   */\n  private _scrollError: {left: number; top: number} | null = null;\n\n  /**\n   * A list of the positions (top, left) of the children in the current range.\n   */\n  private _childrenPos: ChildPositions | null = null;\n\n  // TODO: (graynorton): type\n  private _childMeasurements: ChildMeasurements | null = null;\n\n  private _toBeMeasured: Map<HTMLElement, unknown> = new Map();\n\n  private _rangeChanged = true;\n\n  private _itemsChanged = true;\n\n  private _visibilityChanged = true;\n\n  /**\n   * The HTMLElement that hosts the virtualizer. Set by hostElement.\n   */\n  protected _hostElement?: VirtualizerHostElement;\n\n  private _scrollerController: ScrollerController | null = null;\n\n  private _isScroller = false;\n\n  private _sizer: HTMLElement | null = null;\n\n  /**\n   * Resize observer attached to hostElement.\n   */\n  private _hostElementRO: ResizeObserver | null = null;\n\n  /**\n   * Resize observer attached to children.\n   */\n  private _childrenRO: ResizeObserver | null = null;\n\n  private _mutationObserver: MutationObserver | null = null;\n\n  private _scrollEventListeners: (Element | Window)[] = [];\n  private _scrollEventListenerOptions: AddEventListenerOptions = {\n    passive: true,\n  };\n\n  // TODO (graynorton): Rethink, per longer comment below\n\n  private _loadListener = this._childLoaded.bind(this);\n\n  /**\n   * Index of element to scroll into view, plus scroll\n   * behavior options, as imperatively specified via\n   * `element(index).scrollIntoView()`\n   */\n  private _scrollIntoViewTarget: ScrollElementIntoViewOptions | null = null;\n\n  private _updateScrollIntoViewCoordinates:\n    | ((coordinates: ScrollToCoordinates) => void)\n    | null = null;\n\n  /**\n   * Items to render. Set by items.\n   */\n  private _items: Array<unknown> = [];\n\n  /**\n   * Index of the first child in the range, not necessarily the first visible child.\n   * TODO @straversi: Consider renaming these.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child in the range.\n   */\n  protected _last = -1;\n\n  /**\n   * Index of the first item intersecting the viewport.\n   */\n  private _firstVisible = -1;\n\n  /**\n   * Index of the last item intersecting the viewport.\n   */\n  private _lastVisible = -1;\n\n  protected _scheduled = new WeakSet();\n\n  /**\n   * Invoked at the end of each render cycle: children in the range are\n   * measured, and their dimensions passed to this callback. Use it to layout\n   * children as needed.\n   */\n  protected _measureCallback: ((sizes: ChildMeasurements) => void) | null =\n    null;\n\n  protected _measureChildOverride: MeasureChildFunction | null = null;\n\n  /**\n   * State for `layoutComplete` promise\n   */\n  private _layoutCompletePromise: Promise<void> | null = null;\n  private _layoutCompleteResolver: Function | null = null;\n  private _layoutCompleteRejecter: Function | null = null;\n  private _pendingLayoutComplete: number | null = null;\n\n  constructor(config: VirtualizerConfig) {\n    if (!config) {\n      throw new Error(\n        'Virtualizer constructor requires a configuration object'\n      );\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error(\n        'Virtualizer configuration requires the \"hostElement\" property'\n      );\n    }\n  }\n\n  set items(items: Array<unknown> | undefined) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n\n  _init(config: VirtualizerConfig) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    this._initLayout(config.layout || ({} as BaseLayoutConfig));\n  }\n\n  private async _initObservers() {\n    this._mutationObserver = new MutationObserver(\n      this._finishDOMUpdate.bind(this)\n    );\n    const ResizeObserver = await getResizeObserver();\n    this._hostElementRO = new ResizeObserver(() =>\n      this._hostElementSizeChanged()\n    );\n    this._childrenRO = new ResizeObserver(this._childrenSizeChanged.bind(this));\n  }\n\n  _initHostElement(config: VirtualizerConfig) {\n    const hostElement = (this._hostElement = config.hostElement);\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n\n  async connected() {\n    await this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(\n      this._hostElement!,\n      includeSelf\n    );\n\n    this._scrollerController = new ScrollerController(\n      this,\n      this._clippingAncestors[0]\n    );\n\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n  }\n\n  _observeAndListen() {\n    this._mutationObserver!.observe(this._hostElement!, {childList: true});\n    this._hostElementRO!.observe(this._hostElement!);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach((ancestor) => {\n      ancestor.addEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      );\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO!.observe(ancestor);\n    });\n    this._hostElementRO!.observe(this._scrollerController!.element);\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._scrollEventListeners.forEach((target) =>\n      target.addEventListener('scroll', this, this._scrollEventListenerOptions)\n    );\n  }\n\n  disconnected() {\n    this._scrollEventListeners.forEach((target) =>\n      target.removeEventListener(\n        'scroll',\n        this,\n        this._scrollEventListenerOptions\n      )\n    );\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController = this._scrollerController?.detach(this) || null;\n    this._mutationObserver?.disconnect();\n    this._hostElementRO?.disconnect();\n    this._childrenRO?.disconnect();\n    this._rejectLayoutCompletePromise('disconnected');\n  }\n\n  private _applyVirtualizerStyles() {\n    const hostElement = this._hostElement!;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style as CSSStyleDeclaration & {contain: string};\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n\n  _getSizer() {\n    const hostElement = this._hostElement!;\n    if (!this._sizer) {\n      // Use a pre-existing sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(\n        `[${SIZER_ATTRIBUTE}]`\n      ) as HTMLElement;\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px',\n      });\n      sizer.innerHTML = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n\n  updateLayoutConfig(layoutConfig: LayoutConfigValue) {\n    const Ctor =\n      ((layoutConfig as LayoutSpecifier).type as LayoutConstructor) ||\n      DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete config.type;\n      this._layout.config = config as BaseLayoutConfig;\n      return true;\n    }\n    return false;\n  }\n\n  private async _initLayout(layoutConfig: LayoutConfigValue) {\n    let config: BaseLayoutConfig | undefined;\n    let Ctor: LayoutConstructor | undefined;\n    if (typeof (layoutConfig as LayoutSpecifier).type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = (layoutConfig as LayoutSpecifier).type as LayoutConstructor;\n      // ...while the rest of the specifier is our layout config\n      const copy = {...(layoutConfig as LayoutSpecifier)} as {\n        type?: LayoutConstructor;\n      };\n      delete copy.type;\n      config = copy as BaseLayoutConfig;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig as BaseLayoutConfig;\n    }\n\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js'))\n        .FlowLayout as unknown as LayoutConstructor;\n    }\n\n    this._layout = new Ctor(config);\n\n    if (\n      this._layout.measureChildren &&\n      typeof this._layout.updateItemSizes === 'function'\n    ) {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n    this._layout.addEventListener('scrollsizechange', this);\n    this._layout.addEventListener('scrollerrorchange', this);\n    this._layout.addEventListener('itempositionchange', this);\n    this._layout.addEventListener('rangechange', this);\n    this._layout.addEventListener('unpinned', this);\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement!.addEventListener('load', this._loadListener, true);\n    }\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName(\n        'uv-virtualizing',\n        'measure'\n      );\n      const virtualizationTime = entries\n        .filter(\n          (e) => e.startTime >= this._benchmarkStart! && e.startTime < now\n        )\n        .reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {timeElapsed, virtualizationTime};\n    }\n    return null;\n  }\n\n  private _measureChildren(): void {\n    const mm: ChildMeasurements = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element: Element): ItemBox {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {width, height} = element.getBoundingClientRect();\n    return Object.assign({width, height}, getMargins(element));\n  }\n\n  protected async _schedule(method: Function): Promise<void> {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n\n  async _updateDOM() {\n    const {_rangeChanged, _itemsChanged} = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    } else {\n      this._finishDOMUpdate();\n    }\n  }\n\n  _finishDOMUpdate() {\n    this._children.forEach((child) => this._childrenRO!.observe(child));\n    this._checkScrollIntoViewTarget(this._childrenPos);\n    this._positionChildren(this._childrenPos);\n    this._sizeHostElement(this._scrollSize);\n    this._correctScrollError();\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n\n  _updateLayout() {\n    if (this._layout) {\n      this._layout!.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout!.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  private _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController!.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      this._layout?.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n\n  handleEvent(event: CustomEvent) {\n    switch (event.type) {\n      case 'scroll':\n        if (\n          event.currentTarget === window ||\n          this._clippingAncestors.includes(event.currentTarget as HTMLElement)\n        ) {\n          this._handleScrollEvent();\n        }\n        break;\n      case 'scrollsizechange':\n        this._scrollSize = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'scrollerrorchange':\n        this._scrollError = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'itempositionchange':\n        this._childrenPos = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'rangechange':\n        this._adjustRange(event.detail);\n        this._schedule(this._updateDOM);\n        break;\n      case 'unpinned':\n        this._hostElement!.dispatchEvent(new UnpinnedEvent());\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n\n  get _children(): Array<HTMLElement> {\n    const arr = [];\n    let next = this._hostElement!.firstElementChild as HTMLElement;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling as HTMLElement;\n    }\n    return arr;\n  }\n\n  private _updateView() {\n    const hostElement = this._hostElement;\n    const scrollingElement = this._scrollerController?.element;\n    const layout = this._layout;\n\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n\n      const hostElementBounds = hostElement.getBoundingClientRect();\n\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n\n      const ancestorBounds = this._clippingAncestors.map((ancestor) =>\n        ancestor.getBoundingClientRect()\n      );\n      ancestorBounds.unshift(hostElementBounds);\n\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top,\n      };\n\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight,\n      };\n\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n\n      const height = Math.max(1, bottom - top);\n      const width = Math.max(1, right - left);\n\n      layout.viewportSize = {width, height};\n      layout.viewportScroll = {top: scrollTop, left: scrollLeft};\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  private _sizeHostElement(size?: Size | null) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement!.style;\n      (style.minWidth as string | null) = h ? `${h}px` : '100%';\n      (style.minHeight as string | null) = v ? `${v}px` : '100%';\n    }\n  }\n\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  private _positionChildren(pos: ChildPositions | null) {\n    if (pos) {\n      pos.forEach(({top, left, width, height, xOffset, yOffset}, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          (child.style.left as string | null) =\n            xOffset === undefined ? null : xOffset + 'px';\n          (child.style.top as string | null) =\n            yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n\n  private async _adjustRange(range: InternalRange) {\n    const {_first, _last, _firstVisible, _lastVisible} = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged =\n      this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged =\n      this._visibilityChanged ||\n      this._firstVisible !== _firstVisible ||\n      this._lastVisible !== _lastVisible;\n  }\n\n  private _correctScrollError() {\n    if (this._scrollError) {\n      const {scrollTop, scrollLeft} = this._scrollerController!;\n      const {top, left} = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController!.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left,\n      });\n    }\n  }\n\n  public element(index: number): VirtualizerChildElementProxy | undefined {\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return this._items?.[index] === undefined\n      ? undefined\n      : {\n          scrollIntoView: (options: ScrollIntoViewOptions = {}) =>\n            this._scrollElementIntoView({...options, index}),\n        };\n  }\n\n  private _scrollElementIntoView(options: ScrollElementIntoViewOptions) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout!.getScrollIntoViewCoordinates(options);\n        const {behavior} = options;\n        this._updateScrollIntoViewCoordinates =\n          this._scrollerController!.managedScrollTo(\n            Object.assign(coordinates, {behavior}),\n            () => this._layout!.getScrollIntoViewCoordinates(options),\n            () => (this._scrollIntoViewTarget = null)\n          );\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout!.pin = options;\n      }\n    }\n  }\n\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  private _checkScrollIntoViewTarget(pos: ChildPositions | null) {\n    const {index} = this._scrollIntoViewTarget || {};\n    if (index && pos?.has(index)) {\n      this._updateScrollIntoViewCoordinates!(\n        this._layout!.getScrollIntoViewCoordinates(this._scrollIntoViewTarget!)\n      );\n    }\n  }\n\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  private _notifyRange() {\n    this._hostElement!.dispatchEvent(\n      new RangeChangedEvent({first: this._first, last: this._last})\n    );\n  }\n\n  private _notifyVisibility() {\n    this._hostElement!.dispatchEvent(\n      new VisibilityChangedEvent({\n        first: this._firstVisible,\n        last: this._lastVisible,\n      })\n    );\n  }\n\n  public get layoutComplete(): Promise<void> {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise!;\n  }\n\n  private _rejectLayoutCompletePromise(reason: string) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter!(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() =>\n        requestAnimationFrame(() => this._resolveLayoutCompletePromise())\n      );\n    }\n  }\n\n  private _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n\n  private _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  private _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n\n  private _childLoaded() {}\n\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  private _childrenSizeChanged(changes: ResizeObserverEntry[]) {\n    // Only measure if the layout requires it\n    if (this._layout!.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(\n          change.target as HTMLElement,\n          change.contentRect\n        );\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\n\nfunction getMargins(el: Element): Margins {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft),\n  };\n}\n\nfunction getMarginValue(value: string): number {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el: Element) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return (parentNode as ShadowRoot).host || null;\n  }\n  return null;\n}\n\n///\n\nfunction getElementAncestors(el: HTMLElement, includeSelf = false) {\n  const ancestors = [];\n  let parent = includeSelf ? el : (getParentElement(el) as HTMLElement);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent) as HTMLElement;\n  }\n  return ancestors;\n}\n\nfunction getClippingAncestors(el: HTMLElement, includeSelf = false) {\n  return getElementAncestors(el, includeSelf).filter(\n    (a) => getComputedStyle(a).overflow !== 'visible'\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}